var documenterSearchIndex = {"docs":
[{"location":"#WaterLily","page":"WaterLily","title":"WaterLily","text":"","category":"section"},{"location":"#Introduction-and-Quickstart","page":"WaterLily","title":"Introduction and Quickstart","text":"","category":"section"},{"location":"","page":"WaterLily","title":"WaterLily","text":"WaterLily","category":"page"},{"location":"#WaterLily","page":"WaterLily","title":"WaterLily","text":"WaterLily.jl\n\n(Image: Dev) (Image: Examples) (Image: CI) (Image: codecov) (Image: DOI)\n\n(Image: Julia flow)\n\nOverview\n\nWaterLily.jl is a simple and fast fluid simulator written in pure Julia. This project is supported by awesome libraries developed within the Julia scientific community, and it aims to accelerate and enhance fluid simulations. Watch the JuliaCon2024 talk here:\n\n(Image: JuliaCon2024 still and link)\n\nIf you have used WaterLily for research, please cite us! The 2025 paper describes the main features of the solver and provides benchmarking, validation, and profiling results.\n\n@article{WeymouthFont2025,\n    author = {G.D. Weymouth and B. Font},\n    title = {WaterLily.jl: A differentiable and backend-agnostic Julia solver for incompressible viscous flow around dynamic bodies},\n    doi = {10.1016/j.cpc.2025.109748},\n    journal = {Computer Physics Communications},\n    year = {2025},\n    volume = {315},\n    pages = {109748},\n}\n\nMethod/capabilities\n\nWaterLily solves the unsteady incompressible 2D or 3D Navier-Stokes equations on a Cartesian grid. The pressure Poisson equation is solved with a geometric multigrid method. Solid boundaries are modelled using the Boundary Data Immersion Method. The solver can run on serial CPU, multi-threaded CPU, or GPU backends.\n\nExample: Flow over a circle\n\nWaterLily lets the user can set the domain size and boundary conditions, the fluid viscosity (which determines the Reynolds number), and immerse solid obstacles. A large selection of examples, notebooks, and tutorials are found in the WaterLily-Examples repository. Here, we will illustrate the basics by simulating and plotting the flow over a circle.\n\nWe define the size of the simulation domain as n by m cells. The circle has radius m/8 and is centered at (m/2,m/2). The flow boundary conditions are (U,0), where we set U=1, and the Reynolds number is Re=U*radius/ŒΩ where ŒΩ (Greek \"nu\" U+03BD, not Latin lowercase \"v\") is the kinematic viscosity of the fluid.\n\nusing WaterLily\nfunction circle(n,m;Re=100,U=1)\n    # signed distance function to circle\n    radius, center = m/8, m/2-1\n    sdf(x,t) = ‚àösum(abs2, x .- center) - radius\n\n    Simulation((n,m),   # domain size\n               (U,0),   # domain velocity (& velocity scale)\n               2radius; # length scale\n               ŒΩ=U*2radius/Re,     # fluid viscosity\n               body=AutoBody(sdf)) # geometry\nend\n\nThe circle geometry is defined using a signed distance function. The AutoBody function uses automatic differentiation to infer the other geometric parameters of the body automatically. Replace the circle's distance function with any other, and now you have the flow around something else... such as a donut or the Julia logo. For more complex geometries, ParametricBodies.jl defines a body using any parametric curve, such as a spline. See that repo (and the video above) for examples.\n\nThe code block above return a Simulation with the parameters we've defined. Now we can initialize a simulation (first line) and step it forward in time (second line)\n\ncirc = circle(3*2^5,2^6)\nsim_step!(circ)\n\nNote we've set n,m to be multiples of powers of 2, which is important when using the (very fast) geometric multi-grid solver.\n\nWe can now access and plot whatever variables we like. For example, we can plot the x-component of the velocity field using\n\nusing Plots\nu = circ.flow.u[:,:,1] # first component is x\ncontourf(u') # transpose the array for the plot\n\n(Image: Initial velocity field)\n\nAs you can see, the velocity within the circle is zero, the velocity far from the circle is one, and there are accelerated and decelerated regions around the circle. The sim_step! has only taken a single time step, and this initial flow around our circle looks similar to the potential flow because the viscous boundary layer has not separated yet.\n\nA set of flow metric functions have been implemented, and we can use them to measure the simulation. The following code block defines a function to step the simulation to time t and then use the pressure_force metric to measure the force on the immersed body. The function is applied over a time range, and the forces are plotted.\n\nfunction get_forces!(sim,t)\n    sim_step!(sim,t,remeasure=false)\n    force = WaterLily.pressure_force(sim)\n    force./(0.5sim.L*sim.U^2) # scale the forces!\nend\n\n# Simulate through the time range and get forces\ntime = 1:0.1:50 # time scale is sim.L/sim.U\nforces = [get_forces!(circ,t) for t in time];\n\n#Plot it\nplot(time,[first.(forces) last.(forces)],\n    labels=[\"drag\" \"lift\"],\n    xlabel=\"tU/L\",\n    ylabel=\"Pressure force coefficients\")\n\n(Image: Pressure forces)\n\nWe can also plot the vorticity field instead of the u-velocity to see a snap-shot of the wake.\n\n# Use curl(velocity) to compute vorticity `inside` the domain\nœâ = zeros(size(u));\n@inside œâ[I] = WaterLily.curl(3,I,circ.flow.u)*circ.L/circ.U\n\n# Plot it using WaterLily's Plots Extension\nflood(œâ,clims = (-10,10),border=:none)\n\n(Image: Vorticity field)\n\nNote that flood is a convience function within WaterLily to create 2D flood plots. As you can see, WaterLily correctly predicts that the flow is unsteady, with an alternating vortex street wake, leading to an oscillating side force and drag force.\n\nMulti-threading and GPU backends\n\nWaterLily uses KernelAbstractions.jl to multi-thread on CPU and run on GPU backends. The implementation method and speed-up are documented in the 2024 paper, with costs as low as 1.44 nano-seconds measured per degree of freedom and time step!\n\nNote that multi-threading requires starting Julia with the --threads argument, see the multi-threading section of the manual. If you are running Julia with multiple threads, KernelAbstractions will detect this and multi-thread the loops automatically.\n\nRunning on a GPU requires initializing the Simulation memory on the GPU, and care needs to be taken to move the data back to the CPU for visualization. As an example, let's compare a 3D GPU simulation of a sphere to the 2D multi-threaded CPU circle defined above\n\nusing CUDA,WaterLily\nfunction sphere(n,m;Re=100,U=1,T=Float64,mem=Array)\n    radius, center = m/8, m/2-1\n    body = AutoBody((x,t)->‚àösum(abs2, x .- center) - radius)\n    Simulation((n,m,m),(U,0,0), # 3D array size and BCs\n                2radius;ŒΩ=U*2radius/Re,body, # no change\n                T,   # Floating point type\n                mem) # memory type\nend\n\n@assert CUDA.functional()      # is your CUDA GPU working??\nGPUsim = sphere(3*2^5,2^6;T=Float32,mem=CuArray); # 3D GPU sim!\nprintln(length(GPUsim.flow.u)) # 1.3M degrees-of freedom!\nsim_step!(GPUsim)              # compile GPU code & run one step\n@time sim_step!(GPUsim,50,remeasure=false) # 40s!!\n\nCPUsim = circle(3*2^5,2^6);    # 2D CPU sim\nprintln(length(CPUsim.flow.u)) # 0.013M degrees-of freedom!\nsim_step!(CPUsim)              # compile GPU code & run one step\nprintln(Threads.nthreads())    # I'm using 8 threads\n@time sim_step!(CPUsim,50,remeasure=false) # 28s!!\n\nAs you can see, the 3D sphere set-up is almost identical to the 2D circle, but using 3D arrays means there are almost 1.3M degrees-of-freedom, 100x bigger than in 2D. Never the less, the simulation is quite fast on the GPU, only around 40% slower than the much smaller 2D simulation on a CPU with 8 threads. See the 2024 paper and the examples repo for many more non-trivial examples including running on AMD GPUs.\n\nFinally, KernelAbstractions does incur some CPU allocations for every loop, but other than this sim_step! is completely non-allocating. This is one reason why the speed-up improves as the size of the simulation increases.\n\nContributing and issues\n\nWe always appreciate new contributions, so please submit a pull request with your changes and help us make WaterLily even better! Note that contributions need to be submitted together with benchmark results - WaterLily should always be fast! üòÉ For this, we have a fully automated benchmarking suite that conducts performance tests. In short, to compare your changes with the latest WaterLily, clone the that repo and run the benchmarks with\n\ngit clone https://github.com/WaterLily-jl/WaterLily-Benchmarks && cd WaterLily-Benchmarks\nsh benchmark.sh -wd \"<your/waterlily/path>\" -w \"<your_waterlily_branch> master\"\njulia --project compare.jl\n\nThis will run benchmarks for CPU and GPU backends. If you do not have a GPU, simply pass -b \"Array\" when runnning benchmark.sh. More information on the benchmark suite is available in that README.\n\nOf course, ideas, suggestions, and questions are welcome too! Please raise an issue to address any of these.\n\nDevelopment goals\n\nImmerse obstacles defined by 3D meshes (Meshing.jl)\nMulti-CPU/GPU simulations (https://github.com/WaterLily-jl/WaterLily.jl/pull/141)\nFree-surface physics with (Volume-of-Fluid) or other methods.\n\n\n\n\n\n","category":"module"},{"location":"#Types-Methods-and-Functions","page":"WaterLily","title":"Types Methods and Functions","text":"","category":"section"},{"location":"","page":"WaterLily","title":"WaterLily","text":"CurrentModule = WaterLily","category":"page"},{"location":"","page":"WaterLily","title":"WaterLily","text":"","category":"page"},{"location":"","page":"WaterLily","title":"WaterLily","text":"Modules = [WaterLily]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#WaterLily.AbstractBody","page":"WaterLily","title":"WaterLily.AbstractBody","text":"AbstractBody\n\nImmersed body Abstract Type. Any AbstractBody subtype must implement\n\nd,n,V = measure(body::AbstractBody, x, t=0, fastd¬≤=Inf)\n\nwhere d is the signed distance from x to the body at time t, and n & V are the normal and velocity vectors implied at x. A fast-approximate method can return ‚âàd,zero(x),zero(x) if d^2>fastd¬≤.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.AutoBody","page":"WaterLily","title":"WaterLily.AutoBody","text":"AutoBody(sdf,map=(x,t)->x) <: AbstractBody\n\nsdf(x::AbstractVector,t::Real)::Real: signed distance function\nmap(x::AbstractVector,t::Real)::AbstractVector: coordinate mapping function\n\nImplicitly define a geometry by its sdf and optional coordinate map. Note: the map is composed automatically i.e. sdf(body::AutoBody,x,t) = body.sdf(body.map(x,t),t).\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.Flow","page":"WaterLily","title":"WaterLily.Flow","text":"Flow{D::Int, T::Float, Sf<:AbstractArray{T,D}, Vf<:AbstractArray{T,D+1}, Tf<:AbstractArray{T,D+2}}\n\nComposite type for a multidimensional immersed boundary flow simulation.\n\nFlow solves the unsteady incompressible Navier-Stokes equations on a Cartesian grid. Solid boundaries are modelled using the Boundary Data Immersion Method. The primary variables are the scalar pressure p (an array of dimension D) and the velocity vector field u (an array of dimension D+1).\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.MeanFlow","page":"WaterLily","title":"WaterLily.MeanFlow","text":"MeanFlow{T, Sf<:AbstractArray{T}, Vf<:AbstractArray{T}, Mf<:AbstractArray{T}}\n\nHolds temporal averages of pressure, velocity, and squared-velocity tensor.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.MultiLevelPoisson","page":"WaterLily","title":"WaterLily.MultiLevelPoisson","text":"MultiLevelPoisson{N,M}\n\nComposite type used to solve the pressure Poisson equation with a geometric multigrid method. The only variable is levels, a vector of nested Poisson systems.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.NoBody","page":"WaterLily","title":"WaterLily.NoBody","text":"NoBody\n\nUse for a simulation without a body.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.Poisson","page":"WaterLily","title":"WaterLily.Poisson","text":"Poisson{N,M}\n\nComposite type for conservative variable coefficient Poisson equations:\n\n‚àÆds Œ≤ ‚àÇx/‚àÇn = œÉ\n\nThe resulting linear system is\n\nAx = [L+D+L']x = z\n\nwhere A is symmetric, block-tridiagonal and extremely sparse. Moreover, D[I]=-‚àë·µ¢(L[I,i]+L'[I,i]). This means matrix storage, multiplication, ect can be easily implemented and optimized without external libraries.\n\nTo help iteratively solve the system above, the Poisson structure holds helper arrays for inv(D), the error œµ, and residual r=z-Ax. An iterative solution method then estimates the error œµ=ÃÉA‚Åª¬πr and increments x+=œµ, r-=Aœµ.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.RigidMap","page":"WaterLily","title":"WaterLily.RigidMap","text":"RigidMap(center, Œ∏) <: AbstractBody\n\nx‚ÇÄ::SVector{D}: coordinate of the center of the body\nŒ∏::Union{Real, SVector{3}}: rotation (single angle in 2D, and in 3D these are the rotation angle around                               the x, y, and z axes respectively.)\nV::SVector{D}=zero(center): linear velocity of the center\nx‚Çö::SVector{D}=zero(center): offset of the pivot point compared to center\nœâ::Union{Real, SVector{3}}=zero(Œ∏): angular velocity (scalar in 2D, vector in 3D)\n\nDefine a RigidMap for any AbstractBody using rigid body motion parameters.\n\nRigidMap updates are computed externally via a set of ODEs and then updated in the simulation loop following:\n\nusing WaterLily,StaticArrays\nbody = AutoBody((x,t)->sqrt(sum(abs2,x))-4,RigidMap(SA{Float32}[16,16],0.f0;œâ=0.1f0))\nsim = Simulation((32,32),(1,0),8;body)\nfor n in 1:10\n    # update body motion (example: constant angular velocity)\n    Œ∏ = sim.body.map.Œ∏ + sim.body.map.œâ*sim.flow.Œît[end]\n    sim.body = setmap(sim.body; Œ∏)\n    # remeasure and step\n    sim_step!(sim;remeasure=true)\nend\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.SetBody","page":"WaterLily","title":"WaterLily.SetBody","text":"SetBody\n\nBody defined as a lazy set operation on two AbstractBodys. The operations are only evaluated when measured.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.Simulation","page":"WaterLily","title":"WaterLily.Simulation","text":"Simulation(dims::NTuple, uBC::Union{NTuple,Function}, L::Number;\n           U=norm2(UŒª), Œît=0.25, ŒΩ=0., œµ=1, g=nothing,\n           perdir=(), exitBC=false,\n           body::AbstractBody=NoBody(),\n           T=Float32, mem=Array)\n\nConstructor for a WaterLily.jl simulation:\n\ndims: Simulation domain dimensions.\nuBC: Velocity field applied to boundary and acceleration conditions.     Define a Tuple for constant BCs, or a Function for space and time varying BCs uBC(i,x,t).\nL: Simulation length scale.\nU: Simulation velocity scale. Required if using UŒª::Function.\nŒît: Initial time step.\nŒΩ: Scaled viscosity (Re=UL/ŒΩ).\ng: Domain acceleration, g(i,x,t)=du·µ¢/dt\nœµ: BDIM kernel width.\nperdir: Domain periodic boundary condition in the (i,) direction.\nuŒª: Velocity field applied to the initial condition.     Define a Tuple for homogeneous (per direction) IC, or a Function for space varying IC uŒª(i,x).\nexitBC: Convective exit boundary condition in the i=1 direction.\nbody: Immersed geometry.\nT: Array element type.\nmem: memory location. Array, CuArray, ROCm to run on CPU, NVIDIA, or AMD devices, respectively.\n\nSee files in examples folder for examples.\n\n\n\n\n\n","category":"type"},{"location":"#WaterLily.BC!","page":"WaterLily","title":"WaterLily.BC!","text":"BC!(a,A)\n\nApply boundary conditions to the ghost cells of a vector field. A Dirichlet condition a[I,i]=A[i] is applied to the vector component normal to the domain boundary. For example a‚Çì(x)=A‚Çì ‚àÄ x ‚àà minmax(X). A zero Neumann condition is applied to the tangential components.\n\n\n\n\n\n","category":"function"},{"location":"#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d","page":"WaterLily","title":"WaterLily.CIj","text":"CIj(j,I,k)\n\nReplace j·µó ∞ component of CartesianIndex with k\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.Jacobi!-Tuple{Any}","page":"WaterLily","title":"WaterLily.Jacobi!","text":"Jacobi!(p::Poisson; it=1)\n\nJacobi smoother run it times. Note: This runs for general backends, but is very slow to converge.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.L‚ÇÇ-Tuple{Any}","page":"WaterLily","title":"WaterLily.L‚ÇÇ","text":"L‚ÇÇ(a)\n\nL‚ÇÇ norm of array a excluding ghosts.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.S-Tuple{CartesianIndex{2}, Any}","page":"WaterLily","title":"WaterLily.S","text":"S(I::CartesianIndex,u)\n\nRate-of-strain tensor.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.accelerate!-Tuple{Any, Any, Nothing, Union{Nothing, Tuple}}","page":"WaterLily","title":"WaterLily.accelerate!","text":"accelerate!(r,t,g,U)\n\nAccounts for applied and reference-frame acceleration using r·µ¢ += g(i,x,t)+dU(i,x,t)/dt\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.apply!-Tuple{Any, Any}","page":"WaterLily","title":"WaterLily.apply!","text":"apply!(f, c)\n\nApply a vector function f(i,x) to the faces of a uniform staggered array c or a function f(x) to the center of a uniform array c.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.check_nthreads-Tuple{}","page":"WaterLily","title":"WaterLily.check_nthreads","text":"check_nthreads()\n\nCheck the number of threads available for the Julia session that loads WaterLily. A warning is shown when running in serial (JULIANUMTHREADS=1) with KernelAbstractions enabled.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.curl-Tuple{Any, Any, Any}","page":"WaterLily","title":"WaterLily.curl","text":"curl(i,I,u)\n\nCompute component i of ùêÆ at the edge of cell I. For example curl(3,CartesianIndex(2,2,2),u) will compute œâ‚ÇÉ(x=1.5,y=1.5,z=2) as this edge produces the highest accuracy for this mix of cross derivatives on a staggered grid.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.curvature-Tuple{AbstractMatrix}","page":"WaterLily","title":"WaterLily.curvature","text":"curvature(A::AbstractMatrix)\n\nReturn H,K the mean and Gaussian curvature from A=hessian(sdf). K=tr(minor(A)) in 3D and K=0 in 2D.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.exitBC!-Tuple{Any, Any, Any}","page":"WaterLily","title":"WaterLily.exitBC!","text":"exitBC!(u,u‚Å∞,U,Œît)\n\nApply a 1D convection scheme to fill the ghost cell on the exit of the domain.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.inside-Tuple{AbstractArray}","page":"WaterLily","title":"WaterLily.inside","text":"inside(a;buff=1)\n\nReturn CartesianIndices range excluding a single layer of cells on all boundaries.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N","page":"WaterLily","title":"WaterLily.inside_u","text":"inside_u(dims,j)\n\nReturn CartesianIndices range excluding the ghost-cells on the boundaries of a vector array on face j with size dims.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D, T}, AbstractArray{T, D}}} where {D, T}","page":"WaterLily","title":"WaterLily.interp","text":"interp(x::SVector, arr::AbstractArray)\n\nLinear interpolation from array arr at Cartesian-coordinate x.\n\nNote: This routine works for any number of dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m","page":"WaterLily","title":"WaterLily.ke","text":"ke(I::CartesianIndex,u,U=0)\n\nCompute ¬ΩùêÆ-ùêî¬≤ at center of cell I where U can be used to subtract a background flow (by default, U=0).\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N","page":"WaterLily","title":"WaterLily.loc","text":"loc(i,I) = loc(Ii)\n\nLocation in space of the cell at CartesianIndex I at face i. Using i=0 returns the cell center s.t. loc = I.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.logger","page":"WaterLily","title":"WaterLily.logger","text":"logger(fname=\"WaterLily\")\n\nSet up a logger to write the pressure solver data to a logging file named WaterLily.log.\n\n\n\n\n\n","category":"function"},{"location":"#WaterLily.measure!","page":"WaterLily","title":"WaterLily.measure!","text":"measure!(sim::Simulation,t=timeNext(sim))\n\nMeasure a dynamic body to update the flow and pois coefficients.\n\n\n\n\n\n","category":"function"},{"location":"#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf<:(AbstractArray{T}), Vf<:(AbstractArray{T}), Tf<:(AbstractArray{T})}, AbstractBody}} where {N, T}","page":"WaterLily","title":"WaterLily.measure!","text":"measure!(flow::Flow, body::AbstractBody; t=0, œµ=1)\n\nQueries the body geometry to fill the arrays:\n\nflow.Œº‚ÇÄ, Zeroth kernel moment\nflow.Œº‚ÇÅ, First kernel moment scaled by the body normal\nflow.V,  Body velocity\n\nat time t using an immersion kernel of size œµ.\n\nSee Maertens & Weymouth, doi:10.1016/j.cma.2014.09.007.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.measure-Tuple{AutoBody, Any, Any}","page":"WaterLily","title":"WaterLily.measure","text":"d,n,V = measure(body::AutoBody,x,t;fastd¬≤=Inf)\n\nDetermine the implicit geometric properties from the sdf and map. The gradient of d=sdf(map(x,t)) is used to improve d for pseudo-sdfs. The velocity is determined solely from the optional map function. Skips the n,V calculation when d¬≤>fastd¬≤.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.measure_sdf!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractBody}, Tuple{AbstractArray{T}, AbstractBody, Any}} where T","page":"WaterLily","title":"WaterLily.measure_sdf!","text":"measure_sdf!(a::AbstractArray, body::AbstractBody, t=0; fastd¬≤=0)\n\nUses sdf(body,x,t) to fill a. Defaults to fastd¬≤=0 for quick evaluation.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N","page":"WaterLily","title":"WaterLily.mom_step!","text":"mom_step!(a::Flow,b::AbstractPoisson;Œª=quick,udf=nothing,kwargs...)\n\nIntegrate the Flow one time step using the Boundary Data Immersion Method and the AbstractPoisson pressure solver to project the velocity onto an incompressible flow.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.mult!-Tuple{Poisson, Any}","page":"WaterLily","title":"WaterLily.mult!","text":"mult!(p::Poisson,x)\n\nEfficient function for Poisson matrix-vector multiplication. Fills p.z = p.A x with 0 in the ghost cells.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.nds-Tuple{Any, Any, Any}","page":"WaterLily","title":"WaterLily.nds","text":"nds(body,x,t)\n\nBDIM-masked surface normal.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S<:(AbstractArray{T}), V<:(AbstractArray{T})}}, Tuple{T}} where T","page":"WaterLily","title":"WaterLily.pcg!","text":"pcg!(p::Poisson; it=6)\n\nConjugate-Gradient smoother with Jacobi preditioning. Runs at most it iterations, but will exit early if the Gram-Schmidt update parameter |Œ±| < 1% or |r D‚Åª¬π r| < 1e-8. Note: This runs for general backends and is the default smoother.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.perBC!-Tuple{Any, Tuple{}}","page":"WaterLily","title":"WaterLily.perBC!","text":"perBC!(a,perdir)\n\nApply periodic conditions to the ghost cells of a scalar field.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.perturb!-Tuple{AbstractSimulation}","page":"WaterLily","title":"WaterLily.perturb!","text":"perturb!(sim; noise=0.1)\n\nPerturb the velocity field of a simulation with noise level with respect to velocity scale U.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.pressure_force-Tuple{Any}","page":"WaterLily","title":"WaterLily.pressure_force","text":"pressure_force(sim::Simulation)\n\nCompute the pressure force on an immersed body.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.pressure_moment-Tuple{Any, Any}","page":"WaterLily","title":"WaterLily.pressure_moment","text":"pressure_moment(x‚ÇÄ,sim::Simulation)\n\nComputes the pressure moment on an immersed body relative to point x‚ÇÄ.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.residual!-Tuple{Poisson}","page":"WaterLily","title":"WaterLily.residual!","text":"residual!(p::Poisson)\n\nComputes the residual r = z-Ax and corrects it such that r = 0 if iD==0 which ensures local satisfiability     and sum(r) = 0 which ensures global satisfiability.\n\nThe global correction is done by adjusting all points uniformly, minimizing the local effect. Other approaches are possible.\n\nNote: These corrections mean x is not strictly solving Ax=z, but without the corrections, no solution exists.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.sdf","page":"WaterLily","title":"WaterLily.sdf","text":"d = sdf(a::AbstractBody,x,t=0;fastd¬≤=0)\n\nMeasure only the distance. Defaults to fastd¬≤=0 for quick evaluation.\n\n\n\n\n\n","category":"function"},{"location":"#WaterLily.sdf-2","page":"WaterLily","title":"WaterLily.sdf","text":"d = sdf(body::AutoBody,x,t) = body.sdf(body.map(x,t),t)\n\n\n\n\n\n","category":"function"},{"location":"#WaterLily.sgs!-Tuple{Any, Any}","page":"WaterLily","title":"WaterLily.sgs!","text":"sgs!(flow, t; ŒΩ‚Çú, S, Cs, Œî)\n\nImplements a user-defined function udf to model subgrid-scale LES stresses based on the Boussinesq approximation     œÑ·µÉ·µ¢‚±º = œÑ ≥·µ¢‚±º - (1/3)œÑ ≥‚Çñ‚ÇñŒ¥·µ¢‚±º = -2ŒΩ‚ÇúSÃÖ·µ¢‚±º where             ‚ñÅ‚ñÅ‚ñÅ‚ñÅ     œÑ ≥·µ¢‚±º =  u·µ¢u‚±º - uÃÖ·µ¢uÃÖ‚±º\n\nand we add -‚àÇ‚±º(œÑ·µÉ·µ¢‚±º) to the RHS as a body force (the isotropic part of the tensor is automatically modelled by the pressure gradient term). Users need to define the turbulent viscosity function ŒΩ‚Çú and pass it as a keyword argument to this function together with rate-of-strain tensor array buffer S, Smagorinsky constant Cs, and filter width Œî. For example, the standard Smagorinsky‚ÄìLilly model for the sub-grid scale stresses is\n\nŒΩ‚Çú = (C‚ÇõŒî)¬≤|SÃÖ·µ¢‚±º|=(C‚ÇõŒî)¬≤‚àö(2SÃÖ·µ¢‚±ºSÃÖ·µ¢‚±º)\n\nIt can be implemented as     smagorinsky(I::CartesianIndex{m} where m; S, Cs, Œî) = @views (Cs*Œî)^2*sqrt(dot(S[I,:,:],S[I,:,:])) and passed into sim_step! as a keyword argument together with the varibles than the function needs (S, Cs, and Œî):     sim_step!(sim, ...; udf=sgs, ŒΩ‚Çú=smagorinsky, S, Cs, Œî)\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.sim_info-Tuple{AbstractSimulation}","page":"WaterLily","title":"WaterLily.sim_info","text":"sim_info(sim::AbstractSimulation)\n\nPrints information on the current state of a simulation.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.sim_step!-Tuple{AbstractSimulation, Any}","page":"WaterLily","title":"WaterLily.sim_step!","text":"sim_step!(sim::AbstractSimulation,t_end;remeasure=true,Œª=quick,max_steps=typemax(Int),verbose=false,\n    udf=nothing,kwargs...)\n\nIntegrate the simulation sim up to dimensionless time t_end. If remeasure=true, the body is remeasured at every time step. Can be set to false for static geometries to speed up simulation. A user-defined function udf can be passed to arbitrarily modify the ::Flow during the predictor and corrector steps. If the udf user keyword arguments, these needs to be included in the sim_step! call as well. A Œª::Function function can be passed as a custom convective scheme, following the interface of Œª(u,c,d) (for upstream, central, downstream points).\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.sim_time-Tuple{AbstractSimulation}","page":"WaterLily","title":"WaterLily.sim_time","text":"sim_time(sim::Simulation)\n\nReturn the current dimensionless time of the simulation tU/L where t=sum(Œît), and U,L are the simulation velocity and length scales.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N","page":"WaterLily","title":"WaterLily.slice","text":"slice(dims,i,j,low=1)\n\nReturn CartesianIndices range slicing through an array of size dims in dimension j at index i. low optionally sets the lower extent of the range in the other dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.solver!-Tuple{Poisson}","page":"WaterLily","title":"WaterLily.solver!","text":"solver!(A::Poisson;tol=1e-4,itmx=1e3)\n\nApproximate iterative solver for the Poisson matrix equation Ax=b.\n\nA: Poisson matrix with working arrays.\nA.x: Solution vector. Can start with an initial guess.\nA.z: Right-Hand-Side vector. Will be overwritten!\nA.n[end]: stores the number of iterations performed.\ntol: Convergence tolerance on the L‚ÇÇ-norm residual.\nitmx: Maximum number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.time-Tuple{Flow}","page":"WaterLily","title":"WaterLily.time","text":"time(a::Flow)\n\nCurrent flow time.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.total_force-Tuple{Any}","page":"WaterLily","title":"WaterLily.total_force","text":"total_force(sim::Simulation)\n\nCompute the total force on an immersed body.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.udf!-Tuple{Any, Nothing, Any}","page":"WaterLily","title":"WaterLily.udf!","text":"udf!(flow::Flow,udf::Function,t)\n\nUser defined function using udf::Function to operate on flow::Flow during the predictor and corrector step, in sync with time t. Keyword arguments must be passed to sim_step! for them to be carried over the actual function call.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.viscous_force-Tuple{Any}","page":"WaterLily","title":"WaterLily.viscous_force","text":"viscous_force(sim::Simulation)\n\nCompute the viscous force on an immersed body.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N","page":"WaterLily","title":"WaterLily.Œ¥","text":"Œ¥(i,N::Int)\nŒ¥(i,I::CartesianIndex{N}) where {N}\n\nReturn a CartesianIndex of dimension N which is one at index i and zero elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}","page":"WaterLily","title":"WaterLily.Œª‚ÇÇ","text":"Œª‚ÇÇ(I::CartesianIndex{3},u)\n\nŒª‚ÇÇ is a deformation tensor metric to identify vortex cores. See https://en.wikipedia.org/wiki/Lambda2_method and Jeong, J., & Hussain, F., doi:10.1017/S0022112095000462\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.œâ-Tuple{CartesianIndex{3}, Any}","page":"WaterLily","title":"WaterLily.œâ","text":"œâ(I::CartesianIndex{3},u)\n\nCompute 3-vector ùõö=ùêÆ at the center of cell I.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}","page":"WaterLily","title":"WaterLily.œâ_mag","text":"œâ_mag(I::CartesianIndex{3},u)\n\nCompute ùõö at the center of cell I.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}","page":"WaterLily","title":"WaterLily.œâ_Œ∏","text":"œâ_Œ∏(I::CartesianIndex{3},z,center,u)\n\nCompute ùõöùõâ at the center of cell I where ùõâ is the azimuth direction around vector z passing through center.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.‚àÇ-NTuple{4, Any}","page":"WaterLily","title":"WaterLily.‚àÇ","text":"‚àÇ(i,j,I,u)\n\nCompute u·µ¢x‚±º at center of cell I. Cross terms are computed less accurately than inline terms because of the staggered grid.\n\n\n\n\n\n","category":"method"},{"location":"#WaterLily.@inside-Tuple{Any}","page":"WaterLily","title":"WaterLily.@inside","text":"@inside <expr>\n\nSimple macro to automate efficient loops over cells excluding ghosts. For example,\n\n@inside p[I] = sum(loc(0,I))\n\nbecomes\n\n@loop p[I] = sum(loc(0,I)) over I ‚àà inside(p)\n\nSee @loop.\n\n\n\n\n\n","category":"macro"},{"location":"#WaterLily.@loop-Tuple","page":"WaterLily","title":"WaterLily.@loop","text":"@loop <expr> over <I ‚àà R>\n\nMacro to automate fast loops using @simd when running in serial, or KernelAbstractions when running multi-threaded CPU or GPU.\n\nFor example\n\n@loop a[I,i] += sum(loc(i,I)) over I ‚àà R\n\nbecomes\n\n@simd for I ‚àà R\n    @fastmath @inbounds a[I,i] += sum(loc(i,I))\nend\n\non serial execution, or\n\n@kernel function kern(a,i,@Const(I0))\n    I ‚àà @index(Global,Cartesian)+I0\n    @fastmath @inbounds a[I,i] += sum(loc(i,I))\nend\nkern(get_backend(a),64)(a,i,R[1]-oneunit(R[1]),ndrange=size(R))\n\nwhen multi-threading on CPU or using CuArrays. Note that get_backend is used on the first variable in expr (a in this example).\n\n\n\n\n\n","category":"macro"}]
}
