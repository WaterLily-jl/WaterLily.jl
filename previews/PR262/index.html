<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WaterLily ¬∑ WaterLily.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://WaterLily-jl.github.io/WaterLily.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WaterLily.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>WaterLily</a><ul class="internal"><li><a class="tocitem" href="#Introduction-and-Quickstart"><span>Introduction and Quickstart</span></a></li><li><a class="tocitem" href="#Types-Methods-and-Functions"><span>Types Methods and Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>WaterLily</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WaterLily</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WaterLily"><a class="docs-heading-anchor" href="#WaterLily">WaterLily</a><a id="WaterLily-1"></a><a class="docs-heading-anchor-permalink" href="#WaterLily" title="Permalink"></a></h1><h2 id="Introduction-and-Quickstart"><a class="docs-heading-anchor" href="#Introduction-and-Quickstart">Introduction and Quickstart</a><a id="Introduction-and-Quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Quickstart" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaterLily" href="#WaterLily"><code>WaterLily</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p><strong>WaterLily.jl</strong></p><p><a href="https://WaterLily-jl.github.io/WaterLily.jl/dev/"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/WaterLily-jl/WaterLily-Examples/"><img src="https://img.shields.io/badge/view-examples-blue.svg" alt="Examples"/></a> <a href="https://github.com/WaterLily-jl/WaterLily.jl/actions/workflows/ci.yml"><img src="https://github.com/WaterLily-jl/WaterLily.jl/actions/workflows/ci.yml/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/WaterLily-jl/WaterLily.jl"><img src="https://codecov.io/gh/WaterLily-jl/WaterLily.jl/branch/master/graph/badge.svg?token=8XYFWKOUFN" alt="codecov"/></a> <a href="https://doi.org/10.1016/j.cpc.2025.109748"><img src="https://zenodo.org/badge/DOI/10.1016/j.cpc.2025.109748.svg" alt="DOI"/></a></p><p><img src="assets/julia.gif" alt="Julia flow"/></p><p><strong>Overview</strong></p><p><strong>WaterLily.jl</strong> is a simple and fast fluid simulator written in pure Julia. This project is supported by awesome libraries developed within the Julia scientific community, and it aims to accelerate and enhance fluid simulations. Watch the JuliaCon2024 talk here:</p><p><a href="https://www.youtube.com/watch?v=FwMh2rq9kOU"><img src="assets/JuliaCon2024.png" alt="JuliaCon2024 still and link"/></a></p><p>If you have used WaterLily for research, please <strong>cite us</strong>! The <a href="https://doi.org/10.1016/j.cpc.2025.109748">2025 paper</a> describes the main features of the solver and provides benchmarking, validation, and profiling results.</p><pre><code class="language-julia hljs">@article{WeymouthFont2025,
    author = {G.D. Weymouth and B. Font},
    title = {WaterLily.jl: A differentiable and backend-agnostic Julia solver for incompressible viscous flow around dynamic bodies},
    doi = {10.1016/j.cpc.2025.109748},
    journal = {Computer Physics Communications},
    year = {2025},
    volume = {315},
    pages = {109748},
}</code></pre><p><strong>Method/capabilities</strong></p><p>WaterLily solves the unsteady incompressible 2D or 3D <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. The pressure Poisson equation is solved with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The solver can run on serial CPU, multi-threaded CPU, or GPU backends.</p><p><strong>Example: Flow over a circle</strong></p><p>WaterLily lets the user can set the domain size and boundary conditions, the fluid viscosity (which determines the <a href="https://en.wikipedia.org/wiki/Reynolds_number">Reynolds number</a>), and immerse solid obstacles. A large selection of examples, notebooks, and tutorials are found in the <a href="https://github.com/WaterLily-jl/WaterLily-Examples">WaterLily-Examples</a> repository. Here, we will illustrate the basics by simulating and plotting the flow over a circle.</p><p>We define the size of the simulation domain as <code>n</code> by <code>m</code> cells. The circle has radius <code>m/8</code> and is centered at <code>(m/2,m/2)</code>. The flow boundary conditions are <code>(U,0)</code>, where we set <code>U=1</code>, and the Reynolds number is <code>Re=U*radius/ŒΩ</code> where <code>ŒΩ</code> (Greek &quot;nu&quot; U+03BD, not Latin lowercase &quot;v&quot;) is the kinematic viscosity of the fluid.</p><pre><code class="language-julia hljs">using WaterLily
function circle(n,m;Re=100,U=1)
    # signed distance function to circle
    radius, center = m/8, m/2-1
    sdf(x,t) = ‚àösum(abs2, x .- center) - radius

    Simulation((n,m),   # domain size
               (U,0),   # domain velocity (&amp; velocity scale)
               2radius; # length scale
               ŒΩ=U*2radius/Re,     # fluid viscosity
               body=AutoBody(sdf)) # geometry
end</code></pre><p>The circle geometry is defined using a <a href="https://en.wikipedia.org/wiki/Signed_distance_function#Applications">signed distance function</a>. The <code>AutoBody</code> function uses <a href="https://github.com/JuliaDiff/">automatic differentiation</a> to infer the other geometric parameters of the body automatically. Replace the circle&#39;s distance function with any other, and now you have the flow around something else... such as a <a href="https://github.com/WaterLily-jl/WaterLily-Examples/blob/main/examples/ThreeD_Donut.jl">donut</a> or the <a href="https://github.com/WaterLily-jl/WaterLily-Examples/blob/main/examples/TwoD_Julia.jl">Julia logo</a>. For more complex geometries, <a href="https://github.com/WaterLily-jl/ParametricBodies.jl">ParametricBodies.jl</a> defines a <code>body</code> using any parametric curve, such as a spline. See that repo (and the video above) for examples.</p><p>The code block above return a <code>Simulation</code> with the parameters we&#39;ve defined. Now we can initialize a simulation (first line) and step it forward in time (second line)</p><pre><code class="language-julia hljs">circ = circle(3*2^5,2^6)
sim_step!(circ)</code></pre><p>Note we&#39;ve set <code>n,m</code> to be multiples of powers of 2, which is important when using the (very fast) geometric multi-grid solver.</p><p>We can now access and plot whatever variables we like. For example, we can plot the x-component of the velocity field using</p><pre><code class="language-julia hljs">using Plots
u = circ.flow.u[:,:,1] # first component is x
contourf(u&#39;) # transpose the array for the plot</code></pre><p><img src="assets/u0.png" alt="Initial velocity field"/></p><p>As you can see, the velocity within the circle is zero, the velocity far from the circle is one, and there are accelerated and decelerated regions around the circle. The <code>sim_step!</code> has only taken a single time step, and this initial flow around our circle looks similar to the potential flow because the viscous boundary layer has not separated yet.</p><p>A set of <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/src/Metrics.jl">flow metric functions</a> have been implemented, and we can use them to measure the simulation. The following code block defines a function to step the simulation to time <code>t</code> and then use the <code>pressure_force</code> metric to measure the force on the immersed body. The function is applied over a time range, and the forces are plotted.</p><pre><code class="language-Julia hljs">function get_forces!(sim,t)
    sim_step!(sim,t,remeasure=false)
    force = WaterLily.pressure_force(sim)
    force./(0.5sim.L*sim.U^2) # scale the forces!
end

# Simulate through the time range and get forces
time = 1:0.1:50 # time scale is sim.L/sim.U
forces = [get_forces!(circ,t) for t in time];

#Plot it
plot(time,[first.(forces) last.(forces)],
    labels=[&quot;drag&quot; &quot;lift&quot;],
    xlabel=&quot;tU/L&quot;,
    ylabel=&quot;Pressure force coefficients&quot;)</code></pre><p><img src="assets/forces.png" alt="Pressure forces"/></p><p>We can also plot the vorticity field instead of the u-velocity to see a snap-shot of the wake.</p><pre><code class="language-julia hljs"># Use curl(velocity) to compute vorticity `inside` the domain
œâ = zeros(size(u));
@inside œâ[I] = WaterLily.curl(3,I,circ.flow.u)*circ.L/circ.U

# Plot it using WaterLily&#39;s Plots Extension
flood(œâ,clims = (-10,10),border=:none)</code></pre><p><img src="assets/vort.png" alt="Vorticity field"/></p><p>Note that <code>flood</code> is a convience function within WaterLily to create 2D flood plots. As you can see, WaterLily correctly predicts that the flow is unsteady, with an alternating vortex street wake, leading to an oscillating side force and drag force.</p><p><strong>Multi-threading and GPU backends</strong></p><p>WaterLily uses <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> to multi-thread on CPU and run on GPU backends. The implementation method and speed-up are documented in the <a href="https://physics.paperswithcode.com/paper/waterlily-jl-a-differentiable-and-backend">2024 paper</a>, with costs as low as 1.44 nano-seconds measured per degree of freedom and time step!</p><p>Note that multi-threading requires <em>starting</em> Julia with the <code>--threads</code> argument, see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">the multi-threading section</a> of the manual. If you are running Julia with multiple threads, KernelAbstractions will detect this and multi-thread the loops automatically.</p><p>Running on a GPU requires initializing the <code>Simulation</code> memory on the GPU, and care needs to be taken to move the data back to the CPU for visualization. As an example, let&#39;s compare a <strong>3D</strong> GPU simulation of a sphere to the <strong>2D</strong> multi-threaded CPU circle defined above</p><pre><code class="language-Julia hljs">using CUDA,WaterLily
function sphere(n,m;Re=100,U=1,T=Float64,mem=Array)
    radius, center = m/8, m/2-1
    body = AutoBody((x,t)-&gt;‚àösum(abs2, x .- center) - radius)
    Simulation((n,m,m),(U,0,0), # 3D array size and BCs
                2radius;ŒΩ=U*2radius/Re,body, # no change
                T,   # Floating point type
                mem) # memory type
end

@assert CUDA.functional()      # is your CUDA GPU working??
GPUsim = sphere(3*2^5,2^6;T=Float32,mem=CuArray); # 3D GPU sim!
println(length(GPUsim.flow.u)) # 1.3M degrees-of freedom!
sim_step!(GPUsim)              # compile GPU code &amp; run one step
@time sim_step!(GPUsim,50,remeasure=false) # 40s!!

CPUsim = circle(3*2^5,2^6);    # 2D CPU sim
println(length(CPUsim.flow.u)) # 0.013M degrees-of freedom!
sim_step!(CPUsim)              # compile GPU code &amp; run one step
println(Threads.nthreads())    # I&#39;m using 8 threads
@time sim_step!(CPUsim,50,remeasure=false) # 28s!!</code></pre><p>As you can see, the 3D sphere set-up is almost identical to the 2D circle, but using 3D arrays means there are almost 1.3M degrees-of-freedom, 100x bigger than in 2D. Never the less, the simulation is quite fast on the GPU, only around 40% slower than the much smaller 2D simulation on a CPU with 8 threads. See the <a href="https://physics.paperswithcode.com/paper/waterlily-jl-a-differentiable-and-backend">2024 paper</a> and the <a href="https://github.com/WaterLily-jl/WaterLily-Examples">examples repo</a> for many more non-trivial examples including running on AMD GPUs.</p><p>Finally, KernelAbstractions does incur some CPU allocations for every loop, but other than this <code>sim_step!</code> is completely non-allocating. This is one reason why the speed-up improves as the size of the simulation increases.</p><p><strong>Contributing and issues</strong></p><p>We always appreciate new contributions, so please <a href="https://github.com/WaterLily-jl/WaterLily.jl/compare">submit a pull request</a> with your changes and help us make WaterLily even better! Note that contributions need to be submitted together with benchmark results - WaterLily should always be fast! üòÉ For this, we have a <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks">fully automated benchmarking suite</a> that conducts performance tests. In short, to compare your changes with the latest WaterLily, clone the that repo and run the benchmarks with</p><pre><code class="language-sh hljs">git clone https://github.com/WaterLily-jl/WaterLily-Benchmarks &amp;&amp; cd WaterLily-Benchmarks
sh benchmark.sh -wd &quot;&lt;your/waterlily/path&gt;&quot; -w &quot;&lt;your_waterlily_branch&gt; master&quot;
julia --project compare.jl</code></pre><p>This will run benchmarks for CPU and GPU backends. If you do not have a GPU, simply pass <code>-b &quot;Array&quot;</code> when runnning <code>benchmark.sh</code>. More information on the benchmark suite is available in that <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks/blob/main/README.md">README</a>.</p><p>Of course, ideas, suggestions, and questions are welcome too! Please <a href="https://github.com/WaterLily-jl/WaterLily.jl/issues/new/choose">raise an issue</a> to address any of these.</p><p><strong>Development goals</strong></p><ul><li>Immerse obstacles defined by 3D meshes (<a href="https://github.com/JuliaGeometry/Meshing.jl">Meshing.jl</a>)</li><li>Multi-CPU/GPU simulations (https://github.com/WaterLily-jl/WaterLily.jl/pull/141)</li><li>Free-surface physics with (<a href="https://github.com/TzuYaoHuang/WaterLily.jl/blob/master/src/Multiphase.jl">Volume-of-Fluid</a>) or other methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L1">source</a></section></article><h2 id="Types-Methods-and-Functions"><a class="docs-heading-anchor" href="#Types-Methods-and-Functions">Types Methods and Functions</a><a id="Types-Methods-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-Methods-and-Functions" title="Permalink"></a></h2><ul><li><a href="#WaterLily"><code>WaterLily</code></a></li><li><a href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a></li><li><a href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a></li><li><a href="#WaterLily.Flow"><code>WaterLily.Flow</code></a></li><li><a href="#WaterLily.MeanFlow"><code>WaterLily.MeanFlow</code></a></li><li><a href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a></li><li><a href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a></li><li><a href="#WaterLily.Poisson"><code>WaterLily.Poisson</code></a></li><li><a href="#WaterLily.RigidMap"><code>WaterLily.RigidMap</code></a></li><li><a href="#WaterLily.SetBody"><code>WaterLily.SetBody</code></a></li><li><a href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a></li><li><a href="#WaterLily.BC!"><code>WaterLily.BC!</code></a></li><li><a href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a></li><li><a href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a></li><li><a href="#WaterLily.L‚ÇÇ-Tuple{Any}"><code>WaterLily.L‚ÇÇ</code></a></li><li><a href="#WaterLily.S-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.S</code></a></li><li><a href="#WaterLily.accelerate!-Tuple{Any, Any, Nothing, Union{Nothing, Tuple}}"><code>WaterLily.accelerate!</code></a></li><li><a href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a></li><li><a href="#WaterLily.check_nthreads-Tuple{}"><code>WaterLily.check_nthreads</code></a></li><li><a href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a></li><li><a href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a></li><li><a href="#WaterLily.exitBC!-Tuple{Any, Any, Any}"><code>WaterLily.exitBC!</code></a></li><li><a href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a></li><li><a href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N"><code>WaterLily.inside_u</code></a></li><li><a href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D, T}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a></li><li><a href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a></li><li><a href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a></li><li><a href="#WaterLily.logger"><code>WaterLily.logger</code></a></li><li><a href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a></li><li><a href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure!"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure_sdf!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractBody}, Tuple{AbstractArray{T}, AbstractBody, Any}} where T"><code>WaterLily.measure_sdf!</code></a></li><li><a href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a></li><li><a href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a></li><li><a href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a></li><li><a href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a></li><li><a href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a></li><li><a href="#WaterLily.perturb!-Tuple{AbstractSimulation}"><code>WaterLily.perturb!</code></a></li><li><a href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a></li><li><a href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a></li><li><a href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a></li><li><a href="#WaterLily.sdf"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sdf"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sgs!-Tuple{Any, Any}"><code>WaterLily.sgs!</code></a></li><li><a href="#WaterLily.sim_info-Tuple{AbstractSimulation}"><code>WaterLily.sim_info</code></a></li><li><a href="#WaterLily.sim_step!-Tuple{AbstractSimulation, Any}"><code>WaterLily.sim_step!</code></a></li><li><a href="#WaterLily.sim_time-Tuple{AbstractSimulation}"><code>WaterLily.sim_time</code></a></li><li><a href="#WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a></li><li><a href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a></li><li><a href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a></li><li><a href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a></li><li><a href="#WaterLily.udf!-Tuple{Any, Nothing, Any}"><code>WaterLily.udf!</code></a></li><li><a href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a></li><li><a href="#WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.Œ¥</code></a></li><li><a href="#WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.Œª‚ÇÇ</code></a></li><li><a href="#WaterLily.œà-Tuple{Any}"><code>WaterLily.œà</code></a></li><li><a href="#WaterLily.œà!-Tuple{Any, Any}"><code>WaterLily.œà!</code></a></li><li><a href="#WaterLily.œâ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ</code></a></li><li><a href="#WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ_mag</code></a></li><li><a href="#WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.œâ_Œ∏</code></a></li><li><a href="#WaterLily.‚àÇ-NTuple{4, Any}"><code>WaterLily.‚àÇ</code></a></li><li><a href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a></li><li><a href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AbstractBody" href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBody</code></pre><p>Immersed body Abstract Type. Any <code>AbstractBody</code> subtype must implement</p><pre><code class="language-julia hljs">d,n,V = measure(body::AbstractBody, x, t=0, fastd¬≤=Inf)</code></pre><p>where <code>d</code> is the signed distance from <code>x</code> to the body at time <code>t</code>, and <code>n</code> &amp; <code>V</code> are the normal and velocity vectors implied at <code>x</code>. A fast-approximate method can return <code>‚âàd,zero(x),zero(x)</code> if <code>d^2&gt;fastd¬≤</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AutoBody" href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoBody(sdf,map=(x,t)-&gt;x) &lt;: AbstractBody</code></pre><ul><li><code>sdf(x::AbstractVector,t::Real)::Real</code>: signed distance function</li><li><code>map(x::AbstractVector,t::Real)::AbstractVector</code>: coordinate mapping function</li></ul><p>Implicitly define a geometry by its <code>sdf</code> and optional coordinate <code>map</code>. Note: the <code>map</code> is composed automatically i.e. <code>sdf(body::AutoBody,x,t) = body.sdf(body.map(x,t),t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/AutoBody.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Flow" href="#WaterLily.Flow"><code>WaterLily.Flow</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flow{D::Int, T::Float, Sf&lt;:AbstractArray{T,D}, Vf&lt;:AbstractArray{T,D+1}, Tf&lt;:AbstractArray{T,D+2}}</code></pre><p>Composite type for a multidimensional immersed boundary flow simulation.</p><p>Flow solves the unsteady incompressible <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The primary variables are the scalar pressure <code>p</code> (an array of dimension <code>D</code>) and the velocity vector field <code>u</code> (an array of dimension <code>D+1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Flow.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.MeanFlow" href="#WaterLily.MeanFlow"><code>WaterLily.MeanFlow</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanFlow{T, Sf&lt;:AbstractArray{T}, Vf&lt;:AbstractArray{T}, Mf&lt;:AbstractArray{T}}</code></pre><p>Holds temporal averages of pressure, velocity, and squared-velocity tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.MultiLevelPoisson" href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiLevelPoisson{N,M}</code></pre><p>Composite type used to solve the pressure Poisson equation with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. The only variable is <code>levels</code>, a vector of nested <code>Poisson</code> systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/MultiLevelPoisson.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.NoBody" href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoBody</code></pre><p>Use for a simulation without a body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Poisson" href="#WaterLily.Poisson"><code>WaterLily.Poisson</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Poisson{N,M}</code></pre><p>Composite type for conservative variable coefficient Poisson equations:</p><pre><code class="language-julia hljs">‚àÆds Œ≤ ‚àÇx/‚àÇn = œÉ</code></pre><p>The resulting linear system is</p><pre><code class="language-julia hljs">Ax = [L+D+L&#39;]x = z</code></pre><p>where A is symmetric, block-tridiagonal and extremely sparse. Moreover, <code>D[I]=-‚àë·µ¢(L[I,i]+L&#39;[I,i])</code>. This means matrix storage, multiplication, ect can be easily implemented and optimized without external libraries.</p><p>To help iteratively solve the system above, the Poisson structure holds helper arrays for <code>inv(D)</code>, the error <code>œµ</code>, and residual <code>r=z-Ax</code>. An iterative solution method then estimates the error <code>œµ=ÃÉA‚Åª¬πr</code> and increments <code>x+=œµ</code>, <code>r-=Aœµ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.RigidMap" href="#WaterLily.RigidMap"><code>WaterLily.RigidMap</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RigidMap(center, Œ∏) &lt;: AbstractBody</code></pre><ul><li><code>x‚ÇÄ::SVector{D}</code>: coordinate of the center of the body</li><li><code>Œ∏::Union{Real, SVector{3}}</code>: rotation (single angle in 2D, and in 3D these are the rotation angle around                               the x, y, and z axes respectively.)</li><li><code>V::SVector{D}=zero(center)</code>: linear velocity of the center</li><li><code>x‚Çö::SVector{D}=zero(center)</code>: offset of the pivot point compared to center</li><li><code>œâ::Union{Real, SVector{3}}=zero(Œ∏)</code>: angular velocity (scalar in 2D, vector in 3D)</li></ul><p>Define a <code>RigidMap</code> for any <code>AbstractBody</code> using rigid body motion parameters.</p><p>RigidMap updates are computed externally via a set of ODEs and then updated in the simulation loop following:</p><pre><code class="language-julia hljs">using WaterLily,StaticArrays
body = AutoBody((x,t)-&gt;sqrt(sum(abs2,x))-4,RigidMap(SA{Float32}[16,16],0.f0;œâ=0.1f0))
sim = Simulation((32,32),(1,0),8;body)
for n in 1:10
    # update body motion (example: constant angular velocity)
    Œ∏ = sim.body.map.Œ∏ + sim.body.map.œâ*sim.flow.Œît[end]
    sim.body = setmap(sim.body; Œ∏)
    # remeasure and step
    sim_step!(sim;remeasure=true)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/RigidMap.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.SetBody" href="#WaterLily.SetBody"><code>WaterLily.SetBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetBody</code></pre><p>Body defined as a lazy set operation on two <code>AbstractBody</code>s. The operations are only evaluated when <code>measure</code>d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Simulation" href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(dims::NTuple, uBC::Union{NTuple,Function}, L::Number;
           U=norm2(UŒª), Œît=0.25, ŒΩ=0., œµ=1, g=nothing,
           perdir=(), exitBC=false,
           body::AbstractBody=NoBody(),
           T=Float32, mem=Array)</code></pre><p>Constructor for a WaterLily.jl simulation:</p><ul><li><code>dims</code>: Simulation domain dimensions.</li><li><code>uBC</code>: Velocity field applied to boundary and acceleration conditions.     Define a <code>Tuple</code> for constant BCs, or a <code>Function</code> for space and time varying BCs <code>uBC(i,x,t)</code>.</li><li><code>L</code>: Simulation length scale.</li><li><code>U</code>: Simulation velocity scale. Required if using <code>UŒª::Function</code>.</li><li><code>Œît</code>: Initial time step.</li><li><code>ŒΩ</code>: Scaled viscosity (<code>Re=UL/ŒΩ</code>).</li><li><code>g</code>: Domain acceleration, <code>g(i,x,t)=du·µ¢/dt</code></li><li><code>œµ</code>: BDIM kernel width.</li><li><code>perdir</code>: Domain periodic boundary condition in the <code>(i,)</code> direction.</li><li><code>uŒª</code>: Velocity field applied to the initial condition.     Define a Tuple for homogeneous (per direction) IC, or a <code>Function</code> for space varying IC <code>uŒª(i,x)</code>.</li><li><code>exitBC</code>: Convective exit boundary condition in the <code>i=1</code> direction.</li><li><code>body</code>: Immersed geometry.</li><li><code>T</code>: Array element type.</li><li><code>mem</code>: memory location. <code>Array</code>, <code>CuArray</code>, <code>ROCm</code> to run on CPU, NVIDIA, or AMD devices, respectively.</li></ul><p>See files in <code>examples</code> folder for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L37-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.BC!" href="#WaterLily.BC!"><code>WaterLily.BC!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BC!(a,A)</code></pre><p>Apply boundary conditions to the ghost cells of a <em>vector</em> field. A Dirichlet condition <code>a[I,i]=A[i]</code> is applied to the vector component <em>normal</em> to the domain boundary. For example <code>a‚Çì(x)=A‚Çì ‚àÄ x ‚àà minmax(X)</code>. A zero Neumann condition is applied to the tangential components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d" href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CIj(j,I,k)</code></pre><p>Replace j·µó ∞ component of CartesianIndex with k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Jacobi!-Tuple{Any}" href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobi!(p::Poisson; it=1)</code></pre><p>Jacobi smoother run <code>it</code> times. Note: This runs for general backends, but is <em>very</em> slow to converge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.L‚ÇÇ-Tuple{Any}" href="#WaterLily.L‚ÇÇ-Tuple{Any}"><code>WaterLily.L‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L‚ÇÇ(a)</code></pre><p>L‚ÇÇ norm of array <code>a</code> excluding ghosts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.S-Tuple{CartesianIndex{2}, Any}" href="#WaterLily.S-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.S</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S(I::CartesianIndex,u)</code></pre><p>Rate-of-strain tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.accelerate!-Tuple{Any, Any, Nothing, Union{Nothing, Tuple}}" href="#WaterLily.accelerate!-Tuple{Any, Any, Nothing, Union{Nothing, Tuple}}"><code>WaterLily.accelerate!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accelerate!(r,t,g,U)</code></pre><p>Accounts for applied and reference-frame acceleration using <code>r·µ¢ += g(i,x,t)+dU(i,x,t)/dt</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Flow.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.apply!-Tuple{Any, Any}" href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply!(f, c)</code></pre><p>Apply a vector function <code>f(i,x)</code> to the faces of a uniform staggered array <code>c</code> or a function <code>f(x)</code> to the center of a uniform array <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.check_nthreads-Tuple{}" href="#WaterLily.check_nthreads-Tuple{}"><code>WaterLily.check_nthreads</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_nthreads()</code></pre><p>Check the number of threads available for the Julia session that loads WaterLily. A warning is shown when running in serial (JULIA<em>NUM</em>THREADS=1) with KernelAbstractions enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curl-Tuple{Any, Any, Any}" href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curl(i,I,u)</code></pre><p>Compute component <code>i</code> of <span>$ùõÅ√óùêÆ$</span> at the <strong>edge</strong> of cell <code>I</code>. For example <code>curl(3,CartesianIndex(2,2,2),u)</code> will compute <code>œâ‚ÇÉ(x=1.5,y=1.5,z=2)</code> as this edge produces the highest accuracy for this mix of cross derivatives on a staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curvature-Tuple{AbstractMatrix}" href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curvature(A::AbstractMatrix)</code></pre><p>Return <code>H,K</code> the mean and Gaussian curvature from <code>A=hessian(sdf)</code>. <code>K=tr(minor(A))</code> in 3D and <code>K=0</code> in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/AutoBody.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.exitBC!-Tuple{Any, Any, Any}" href="#WaterLily.exitBC!-Tuple{Any, Any, Any}"><code>WaterLily.exitBC!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exitBC!(u,u‚Å∞,U,Œît)</code></pre><p>Apply a 1D convection scheme to fill the ghost cell on the exit of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside-Tuple{AbstractArray}" href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside(a;buff=1)</code></pre><p>Return CartesianIndices range excluding a single layer of cells on all boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N" href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N"><code>WaterLily.inside_u</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside_u(dims,j)</code></pre><p>Return CartesianIndices range excluding the ghost-cells on the boundaries of a <em>vector</em> array on face <code>j</code> with size <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D, T}, AbstractArray{T, D}}} where {D, T}" href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D, T}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interp(x::SVector, arr::AbstractArray)</code></pre><p>Linear interpolation from array <code>arr</code> at Cartesian-coordinate <code>x</code>.</p><p>Note: This routine works for any number of dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m" href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ke(I::CartesianIndex,u,U=0)</code></pre><p>Compute <span>$¬Ω‚à•ùêÆ-ùêî‚à•¬≤$</span> at center of cell <code>I</code> where <code>U</code> can be used to subtract a background flow (by default, <code>U=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N" href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loc(i,I) = loc(Ii)</code></pre><p>Location in space of the cell at CartesianIndex <code>I</code> at face <code>i</code>. Using <code>i=0</code> returns the cell center s.t. <code>loc = I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.logger" href="#WaterLily.logger"><code>WaterLily.logger</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logger(fname=&quot;WaterLily&quot;)</code></pre><p>Set up a logger to write the pressure solver data to a logging file named <code>WaterLily.log</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!" href="#WaterLily.measure!"><code>WaterLily.measure!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure!(sim::Simulation,t=timeNext(sim))</code></pre><p>Measure a dynamic <code>body</code> to update the <code>flow</code> and <code>pois</code> coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}" href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure!(flow::Flow, body::AbstractBody; t=0, œµ=1)</code></pre><p>Queries the body geometry to fill the arrays:</p><ul><li><code>flow.Œº‚ÇÄ</code>, Zeroth kernel moment</li><li><code>flow.Œº‚ÇÅ</code>, First kernel moment scaled by the body normal</li><li><code>flow.V</code>,  Body velocity</li></ul><p>at time <code>t</code> using an immersion kernel of size <code>œµ</code>.</p><p>See Maertens &amp; Weymouth, doi:<a href="https://doi.org/10.1016/j.cma.2014.09.007">10.1016/j.cma.2014.09.007</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure-Tuple{AutoBody, Any, Any}" href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d,n,V = measure(body::AutoBody,x,t;fastd¬≤=Inf)</code></pre><p>Determine the implicit geometric properties from the <code>sdf</code> and <code>map</code>. The gradient of <code>d=sdf(map(x,t))</code> is used to improve <code>d</code> for pseudo-sdfs. The velocity is determined <em>solely</em> from the optional <code>map</code> function. Skips the <code>n,V</code> calculation when <code>d¬≤&gt;fastd¬≤</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/AutoBody.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure_sdf!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractBody}, Tuple{AbstractArray{T}, AbstractBody, Any}} where T" href="#WaterLily.measure_sdf!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractBody}, Tuple{AbstractArray{T}, AbstractBody, Any}} where T"><code>WaterLily.measure_sdf!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_sdf!(a::AbstractArray, body::AbstractBody, t=0; fastd¬≤=0)</code></pre><p>Uses <code>sdf(body,x,t)</code> to fill <code>a</code>. Defaults to fastd¬≤=0 for quick evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N" href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mom_step!(a::Flow,b::AbstractPoisson;Œª=quick,udf=nothing,kwargs...)</code></pre><p>Integrate the <code>Flow</code> one time step using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a> and the <code>AbstractPoisson</code> pressure solver to project the velocity onto an incompressible flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Flow.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mult!-Tuple{Poisson, Any}" href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mult!(p::Poisson,x)</code></pre><p>Efficient function for Poisson matrix-vector multiplication. Fills <code>p.z = p.A x</code> with 0 in the ghost cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.nds-Tuple{Any, Any, Any}" href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nds(body,x,t)</code></pre><p>BDIM-masked surface normal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T" href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pcg!(p::Poisson; it=6)</code></pre><p>Conjugate-Gradient smoother with Jacobi preditioning. Runs at most <code>it</code> iterations, but will exit early if the Gram-Schmidt update parameter <code>|Œ±| &lt; 1%</code> or <code>|r D‚Åª¬π r| &lt; 1e-8</code>. Note: This runs for general backends and is the default smoother.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.perBC!-Tuple{Any, Tuple{}}" href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perBC!(a,perdir)</code></pre><p>Apply periodic conditions to the ghost cells of a <em>scalar</em> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.perturb!-Tuple{AbstractSimulation}" href="#WaterLily.perturb!-Tuple{AbstractSimulation}"><code>WaterLily.perturb!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perturb!(sim; noise=0.1)</code></pre><p>Perturb the velocity field of a simulation with <code>noise</code> level with respect to velocity scale <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_force-Tuple{Any}" href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_force(sim::Simulation)</code></pre><p>Compute the pressure force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_moment-Tuple{Any, Any}" href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_moment(x‚ÇÄ,sim::Simulation)</code></pre><p>Computes the pressure moment on an immersed body relative to point x‚ÇÄ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.residual!-Tuple{Poisson}" href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual!(p::Poisson)</code></pre><p>Computes the residual <code>r = z-Ax</code> and corrects it such that <code>r = 0</code> if <code>iD==0</code> which ensures local satisfiability     and <code>sum(r) = 0</code> which ensures global satisfiability.</p><p>The global correction is done by adjusting all points uniformly, minimizing the local effect. Other approaches are possible.</p><p>Note: These corrections mean <code>x</code> is not strictly solving <code>Ax=z</code>, but without the corrections, no solution exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf" href="#WaterLily.sdf"><code>WaterLily.sdf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d = sdf(body::AutoBody,x,t) = body.sdf(body.map(x,t),t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/AutoBody.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf" href="#WaterLily.sdf"><code>WaterLily.sdf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d = sdf(a::AbstractBody,x,t=0;fastd¬≤=0)</code></pre><p>Measure only the distance. Defaults to fastd¬≤=0 for quick evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Body.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sgs!-Tuple{Any, Any}" href="#WaterLily.sgs!-Tuple{Any, Any}"><code>WaterLily.sgs!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sgs!(flow, t; ŒΩ‚Çú, S, Cs, Œî)</code></pre><p>Implements a user-defined function <code>udf</code> to model subgrid-scale LES stresses based on the Boussinesq approximation     œÑ·µÉ·µ¢‚±º = œÑ ≥·µ¢‚±º - (1/3)œÑ ≥‚Çñ‚ÇñŒ¥·µ¢‚±º = -2ŒΩ‚ÇúSÃÖ·µ¢‚±º where             ‚ñÅ‚ñÅ‚ñÅ‚ñÅ     œÑ ≥·µ¢‚±º =  u·µ¢u‚±º - uÃÖ·µ¢uÃÖ‚±º</p><p>and we add -‚àÇ‚±º(œÑ·µÉ·µ¢‚±º) to the RHS as a body force (the isotropic part of the tensor is automatically modelled by the pressure gradient term). Users need to define the turbulent viscosity function <code>ŒΩ‚Çú</code> and pass it as a keyword argument to this function together with rate-of-strain tensor array buffer <code>S</code>, Smagorinsky constant <code>Cs</code>, and filter width <code>Œî</code>. For example, the standard Smagorinsky‚ÄìLilly model for the sub-grid scale stresses is</p><pre><code class="language-julia hljs">ŒΩ‚Çú = (C‚ÇõŒî)¬≤|SÃÖ·µ¢‚±º|=(C‚ÇõŒî)¬≤‚àö(2SÃÖ·µ¢‚±ºSÃÖ·µ¢‚±º)</code></pre><p>It can be implemented as     <code>smagorinsky(I::CartesianIndex{m} where m; S, Cs, Œî) = @views (Cs*Œî)^2*sqrt(dot(S[I,:,:],S[I,:,:]))</code> and passed into <code>sim_step!</code> as a keyword argument together with the varibles than the function needs (<code>S</code>, <code>Cs</code>, and <code>Œî</code>):     <code>sim_step!(sim, ...; udf=sgs, ŒΩ‚Çú=smagorinsky, S, Cs, Œî)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L289-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_info-Tuple{AbstractSimulation}" href="#WaterLily.sim_info-Tuple{AbstractSimulation}"><code>WaterLily.sim_info</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_info(sim::AbstractSimulation)</code></pre><p>Prints information on the current state of a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_step!-Tuple{AbstractSimulation, Any}" href="#WaterLily.sim_step!-Tuple{AbstractSimulation, Any}"><code>WaterLily.sim_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_step!(sim::AbstractSimulation,t_end;remeasure=true,Œª=quick,max_steps=typemax(Int),verbose=false,
    udf=nothing,kwargs...)</code></pre><p>Integrate the simulation <code>sim</code> up to dimensionless time <code>t_end</code>. If <code>remeasure=true</code>, the body is remeasured at every time step. Can be set to <code>false</code> for static geometries to speed up simulation. A user-defined function <code>udf</code> can be passed to arbitrarily modify the <code>::Flow</code> during the predictor and corrector steps. If the <code>udf</code> user keyword arguments, these needs to be included in the <code>sim_step!</code> call as well. A <code>Œª::Function</code> function can be passed as a custom convective scheme, following the interface of <code>Œª(u,c,d)</code> (for upstream, central, downstream points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L95-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_time-Tuple{AbstractSimulation}" href="#WaterLily.sim_time-Tuple{AbstractSimulation}"><code>WaterLily.sim_time</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_time(sim::Simulation)</code></pre><p>Return the current dimensionless time of the simulation <code>tU/L</code> where <code>t=sum(Œît)</code>, and <code>U</code>,<code>L</code> are the simulation velocity and length scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/WaterLily.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N" href="#WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice(dims,i,j,low=1)</code></pre><p>Return <code>CartesianIndices</code> range slicing through an array of size <code>dims</code> in dimension <code>j</code> at index <code>i</code>. <code>low</code> optionally sets the lower extent of the range in the other dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.solver!-Tuple{Poisson}" href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solver!(A::Poisson;tol=1e-4,itmx=1e3)</code></pre><p>Approximate iterative solver for the Poisson matrix equation <code>Ax=b</code>.</p><ul><li><code>A</code>: Poisson matrix with working arrays.</li><li><code>A.x</code>: Solution vector. Can start with an initial guess.</li><li><code>A.z</code>: Right-Hand-Side vector. Will be overwritten!</li><li><code>A.n[end]</code>: stores the number of iterations performed.</li><li><code>tol</code>: Convergence tolerance on the <code>L‚ÇÇ</code>-norm residual.</li><li><code>itmx</code>: Maximum number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Poisson.jl#L150-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.time-Tuple{Flow}" href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time(a::Flow)</code></pre><p>Current flow time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Flow.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.total_force-Tuple{Any}" href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_force(sim::Simulation)</code></pre><p>Compute the total force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.udf!-Tuple{Any, Nothing, Any}" href="#WaterLily.udf!-Tuple{Any, Nothing, Any}"><code>WaterLily.udf!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">udf!(flow::Flow,udf::Function,t)</code></pre><p>User defined function using <code>udf::Function</code> to operate on <code>flow::Flow</code> during the predictor and corrector step, in sync with time <code>t</code>. Keyword arguments must be passed to <code>sim_step!</code> for them to be carried over the actual function call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Flow.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.viscous_force-Tuple{Any}" href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">viscous_force(sim::Simulation)</code></pre><p>Compute the viscous force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N" href="#WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.Œ¥</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Œ¥(i,N::Int)
Œ¥(i,I::CartesianIndex{N}) where {N}</code></pre><p>Return a CartesianIndex of dimension <code>N</code> which is one at index <code>i</code> and zero elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.Œª‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Œª‚ÇÇ(I::CartesianIndex{3},u)</code></pre><p>Œª‚ÇÇ is a deformation tensor metric to identify vortex cores. See <a href="https://en.wikipedia.org/wiki/Lambda2_method">https://en.wikipedia.org/wiki/Lambda2_method</a> and Jeong, J., &amp; Hussain, F., doi:<a href="https://doi.org/10.1017/S0022112095000462">10.1017/S0022112095000462</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œà!-Tuple{Any, Any}" href="#WaterLily.œà!-Tuple{Any, Any}"><code>WaterLily.œà!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œà!(pois, u)</code></pre><p>Streamline function for 2D flows, solving Œîœà = -œâ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œà-Tuple{Any}" href="#WaterLily.œà-Tuple{Any}"><code>WaterLily.œà</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œà(sim)</code></pre><p>Streamline function for 2D flows, solving Œîœà = -œâ. Allocates a new MultiLevelPoisson solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.œâ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ(I::CartesianIndex{3},u)</code></pre><p>Compute 3-vector <span>$ùõö=ùõÅ√óùêÆ$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ_mag</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ_mag(I::CartesianIndex{3},u)</code></pre><p>Compute <span>$‚à•ùõö‚à•$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}" href="#WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.œâ_Œ∏</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ_Œ∏(I::CartesianIndex{3},z,center,u)</code></pre><p>Compute <span>$ùõö‚ãÖùõâ$</span> at the center of cell <code>I</code> where <span>$ùõâ$</span> is the azimuth direction around vector <code>z</code> passing through <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.‚àÇ-NTuple{4, Any}" href="#WaterLily.‚àÇ-NTuple{4, Any}"><code>WaterLily.‚àÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇ(i,j,I,u)</code></pre><p>Compute <span>$‚àÇu·µ¢/‚àÇx‚±º$</span> at center of cell <code>I</code>. Cross terms are computed less accurately than inline terms because of the staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/Metrics.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@inside-Tuple{Any}" href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@inside &lt;expr&gt;</code></pre><p>Simple macro to automate efficient loops over cells excluding ghosts. For example,</p><pre><code class="language-julia hljs">@inside p[I] = sum(loc(0,I))</code></pre><p>becomes</p><pre><code class="language-julia hljs">@loop p[I] = sum(loc(0,I)) over I ‚àà inside(p)</code></pre><p>See <a href="#WaterLily.@loop-Tuple"><code>@loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@loop-Tuple" href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@loop &lt;expr&gt; over &lt;I ‚àà R&gt;</code></pre><p>Macro to automate fast loops using @simd when running in serial, or KernelAbstractions when running multi-threaded CPU or GPU.</p><p>For example</p><pre><code class="language-julia hljs">@loop a[I,i] += sum(loc(i,I)) over I ‚àà R</code></pre><p>becomes</p><pre><code class="language-julia hljs">@simd for I ‚àà R
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end</code></pre><p>on serial execution, or</p><pre><code class="language-julia hljs">@kernel function kern(a,i,@Const(I0))
    I ‚àà @index(Global,Cartesian)+I0
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end
kern(get_backend(a),64)(a,i,R[1]-oneunit(R[1]),ndrange=size(R))</code></pre><p>when multi-threading on CPU or using CuArrays. Note that <code>get_backend</code> is used on the <em>first</em> variable in <code>expr</code> (<code>a</code> in this example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/07b9b7d3fbfeed6202424a70ef07b979c810c3de/src/util.jl#L105-L131">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 24 December 2025 19:29">Wednesday 24 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
