<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WaterLily · WaterLily.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://WaterLily-jl.github.io/WaterLily.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WaterLily.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>WaterLily</a><ul class="internal"><li><a class="tocitem" href="#Introduction-and-Quickstart"><span>Introduction and Quickstart</span></a></li><li><a class="tocitem" href="#Types-Methods-and-Functions"><span>Types Methods and Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>WaterLily</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WaterLily</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WaterLily"><a class="docs-heading-anchor" href="#WaterLily">WaterLily</a><a id="WaterLily-1"></a><a class="docs-heading-anchor-permalink" href="#WaterLily" title="Permalink"></a></h1><h2 id="Introduction-and-Quickstart"><a class="docs-heading-anchor" href="#Introduction-and-Quickstart">Introduction and Quickstart</a><a id="Introduction-and-Quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Quickstart" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaterLily" href="#WaterLily"><code>WaterLily</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>WaterLily.jl</strong></p><p><a href="https://WaterLily-jl.github.io/WaterLily.jl/dev/"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/WaterLily-jl/WaterLily-Examples/"><img src="https://img.shields.io/badge/view-examples-blue.svg" alt="Examples"/></a> <a href="https://github.com/WaterLily-jl/WaterLily.jl/actions"><img src="https://github.com/WaterLily-jl/WaterLily.jl/workflows/CI/badge.svg?branch=master&amp;event=push" alt="CI"/></a> <a href="https://codecov.io/gh/WaterLily-jl/WaterLily.jl"><img src="https://codecov.io/gh/WaterLily-jl/WaterLily.jl/branch/master/graph/badge.svg?token=8XYFWKOUFN" alt="codecov"/></a></p><p><img src="assets/julia.gif" alt="Julia flow"/></p><p><strong>Overview</strong></p><p><strong>WaterLily.jl</strong> is a simple and fast fluid simulator written in pure Julia. This project is supported by awesome libraries developed within the Julia scientific community, and it aims to accelerate and enhance fluid simulations. Watch the JuliaCon2024 talk here:</p><p><a href="https://www.youtube.com/watch?v=FwMh2rq9kOU"><img src="assets/JuliaCon2024.png" alt="JuliaCon2024 still and link"/></a></p><p>If you have used WaterLily for research, please <strong>cite us</strong>! The <a href="https://physics.paperswithcode.com/paper/waterlily-jl-a-differentiable-and-backend">2024 paper</a> describes the main features of the solver and provides benchmarking, validation, and profiling results.</p><pre><code class="nohighlight hljs">@misc{WeymouthFont2024,
    title         = {WaterLily.jl: A differentiable and backend-agnostic Julia solver to simulate incompressible viscous flow and dynamic bodies},
    author        = {Gabriel D. Weymouth and Bernat Font},
    url           = {https://arxiv.org/abs/2407.16032},
    eprint        = {2407.16032},
    archivePrefix = {arXiv},
    year          = {2024},
    primaryClass  = {physics.flu-dyn}
}</code></pre><p><strong>Method/capabilities</strong></p><p>WaterLily solves the unsteady incompressible 2D or 3D <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. The pressure Poisson equation is solved with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The solver can run on serial CPU, multi-threaded CPU, or GPU backends.</p><p><strong>Example: Flow over a circle</strong></p><p>WaterLily lets the user can set the domain size and boundary conditions, the fluid viscosity (which determines the <a href="https://en.wikipedia.org/wiki/Reynolds_number">Reynolds number</a>), and immerse solid obstacles. A large selection of examples, notebooks, and tutorials are found in the <a href="https://github.com/WaterLily-jl/WaterLily-Examples">WaterLily-Examples</a> repository. Here, we will illustrate the basics by simulating and plotting the flow over a circle.</p><p>We define the size of the simulation domain as <code>n</code> by <code>m</code> cells. The circle has radius <code>m/8</code> and is centered at <code>(m/2,m/2)</code>. The flow boundary conditions are <code>(U,0)</code>, where we set <code>U=1</code>, and the Reynolds number is <code>Re=U*radius/ν</code> where <code>ν</code> (Greek &quot;nu&quot; U+03BD, not Latin lowercase &quot;v&quot;) is the kinematic viscosity of the fluid.</p><pre><code class="language-julia hljs">using WaterLily
function circle(n,m;Re=100,U=1)
    # signed distance function to circle
    radius, center = m/8, m/2-1
    sdf(x,t) = √sum(abs2, x .- center) - radius

    Simulation((n,m),   # domain size
               (U,0),   # domain velocity (&amp; velocity scale)
               2radius; # length scale
               ν=U*2radius/Re,     # fluid viscosity
               body=AutoBody(sdf)) # geometry
end</code></pre><p>The circle geometry is defined using a <a href="https://en.wikipedia.org/wiki/Signed_distance_function#Applications">signed distance function</a>. The <code>AutoBody</code> function uses <a href="https://github.com/JuliaDiff/">automatic differentiation</a> to infer the other geometric parameters of the body automatically. Replace the circle&#39;s distance function with any other, and now you have the flow around something else... such as a <a href="https://github.com/WaterLily-jl/WaterLily-Examples/blob/main/examples/ThreeD_Donut.jl">donut</a> or the <a href="https://github.com/WaterLily-jl/WaterLily-Examples/blob/main/examples/TwoD_Julia.jl">Julia logo</a>. For more complex geometries, <a href="https://github.com/WaterLily-jl/ParametricBodies.jl">ParametricBodies.jl</a> defines a <code>body</code> using any parametric curve, such as a spline. See that repo (and the video above) for examples.</p><p>The code block above return a <code>Simulation</code> with the parameters we&#39;ve defined. Now we can initialize a simulation (first line) and step it forward in time (second line)</p><pre><code class="language-julia hljs">circ = circle(3*2^5,2^6)
sim_step!(circ)</code></pre><p>Note we&#39;ve set <code>n,m</code> to be multiples of powers of 2, which is important when using the (very fast) geometric multi-grid solver.</p><p>We can now access and plot whatever variables we like. For example, we can plot the x-component of the velocity field using</p><pre><code class="language-julia hljs">using Plots
u = circ.flow.u[:,:,1] # first component is x
contourf(u&#39;) # transpose the array for the plot</code></pre><p><img src="assets/u0.png" alt="Initial velocity field"/></p><p>As you can see, the velocity within the circle is zero, the velocity far from the circle is one, and there are accelerated and decelerated regions around the circle. The <code>sim_step!</code> has only taken a single time step, and this initial flow around our circle looks similar to the potential flow because the viscous boundary layer has not separated yet.</p><p>A set of <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/src/Metrics.jl">flow metric functions</a> have been implemented, and we can use them to measure the simulation. The following code block defines a function to step the simulation to time <code>t</code> and then use the <code>pressure_force</code> metric to measure the force on the immersed body. The function is applied over a time range, and the forces are plotted.</p><pre><code class="language-Julia hljs">function get_forces!(sim,t)
    sim_step!(sim,t,remeasure=false)
    force = WaterLily.pressure_force(sim)
    force./(0.5sim.L*sim.U^2) # scale the forces!
end

# Simulate through the time range and get forces
time = 1:0.1:50 # time scale is sim.L/sim.U
forces = [get_forces!(circ,t) for t in time];

#Plot it
plot(time,[first.(forces), last.(forces)],
    labels=permutedims([&quot;drag&quot;,&quot;lift&quot;]),
    xlabel=&quot;tU/L&quot;,
    ylabel=&quot;Pressure force coefficients&quot;)</code></pre><p><img src="assets/forces.png" alt="Pressure forces"/></p><p>We can also plot the vorticity field instead of the u-velocity to see a snap-shot of the wake.</p><pre><code class="language-julia hljs"># Use curl(velocity) to compute vorticity `inside` the domain
ω = zeros(size(u));
@inside ω[I] = WaterLily.curl(3,I,circ.flow.u)*circ.L/circ.U

# Plot it
clims = (-6,6)
contourf(clamp.(ω,clims...)&#39;; clims,
    color=palette(:RdBu,9),linewidth=0,levels=8,
    aspect_ratio=:equal,border=:none)</code></pre><p><img src="assets/vort.png" alt="Vorticity field"/></p><p>As you can see, WaterLily correctly predicts that the flow is unsteady, with an alternating vortex street wake, leading to an oscillating side force and drag force.</p><p><strong>Multi-threading and GPU backends</strong></p><p>WaterLily uses <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> to multi-thread on CPU and run on GPU backends. The implementation method and speed-up are documented in the <a href="https://physics.paperswithcode.com/paper/waterlily-jl-a-differentiable-and-backend">2024 paper</a>, with costs as low as 1.44 nano-seconds measured per degree of freedom and time step!</p><p>Note that multi-threading requires <em>starting</em> Julia with the <code>--threads</code> argument, see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">the multi-threading section</a> of the manual. If you are running Julia with multiple threads, KernelAbstractions will detect this and multi-thread the loops automatically.</p><p>Running on a GPU requires initializing the <code>Simulation</code> memory on the GPU, and care needs to be taken to move the data back to the CPU for visualization. As an example, let&#39;s compare a <strong>3D</strong> GPU simulation of a sphere to the <strong>2D</strong> multi-threaded CPU circle defined above</p><pre><code class="language-Julia hljs">using CUDA,WaterLily
function sphere(n,m;Re=100,U=1,T=Float64,mem=Array)
    radius, center = m/8, m/2-1
    body = AutoBody((x,t)-&gt;√sum(abs2, x .- center) - radius)
    Simulation((n,m,m),(U,0,0), # 3D array size and BCs
                2radius;ν=U*2radius/Re,body, # no change
                T,   # Floating point type
                mem) # memory type
end

@assert CUDA.functional()      # is your CUDA GPU working??
GPUsim = sphere(3*2^5,2^6;T=Float32,mem=CuArray); # 3D GPU sim!
println(length(GPUsim.flow.u)) # 1.3M degrees-of freedom!
sim_step!(GPUsim)              # compile GPU code &amp; run one step
@time sim_step!(GPUsim,50,remeasure=false) # 40s!!

CPUsim = circle(3*2^5,2^6);    # 2D CPU sim
println(length(CPUsim.flow.u)) # 0.013M degrees-of freedom!
sim_step!(CPUsim)              # compile GPU code &amp; run one step
println(Threads.nthreads())    # I&#39;m using 8 threads
@time sim_step!(CPUsim,50,remeasure=false) # 28s!!</code></pre><p>As you can see, the 3D sphere set-up is almost identical to the 2D circle, but using 3D arrays means there are almost 1.3M degrees-of-freedom, 100x bigger than in 2D. Never the less, the simulation is quite fast on the GPU, only around 40% slower than the much smaller 2D simulation on a CPU with 8 threads. See the <a href="https://physics.paperswithcode.com/paper/waterlily-jl-a-differentiable-and-backend">2024 paper</a> and the <a href="https://github.com/WaterLily-jl/WaterLily-Examples">examples repo</a> for many more non-trivial examples including running on AMD GPUs.</p><p>Finally, KernelAbstractions does incur some CPU allocations for every loop, but other than this <code>sim_step!</code> is completely non-allocating. This is one reason why the speed-up improves as the size of the simulation increases.</p><p><strong>Contributing and issues</strong></p><p>We always appreciate new contributions, so please <a href="https://github.com/WaterLily-jl/WaterLily.jl/compare">submit a pull request</a> with your changes and help us make WaterLily even better! Note that contributions need to be submitted together with benchmark results - WaterLily should always be fast! 😃 For this, we have a <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks">fully automated benchmarking suite</a> that conducts performance tests. In short, to compare your changes with the latest WaterLily, clone the that repo and run the benchmarks with</p><pre><code class="language-sh hljs">git clone https://github.com/WaterLily-jl/WaterLily-Benchmarks &amp;&amp; cd WaterLily-Benchmarks
sh benchmark.sh -wd &quot;&lt;your/waterlily/path&gt;&quot; -w &quot;&lt;your_waterlily_branch&gt; master&quot;
julia --project compare.jl</code></pre><p>This will run benchmarks for CPU and GPU backends. If you do not have a GPU, simply pass <code>-b &quot;Array&quot;</code> when runnning <code>benchmark.sh</code>. More information on the benchmark suite is available in that <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks/blob/main/README.md">README</a>.</p><p>Of course, ideas, suggestions, and questions are welcome too! Please <a href="https://github.com/WaterLily-jl/WaterLily.jl/issues/new/choose">raise an issue</a> to address any of these.</p><p><strong>Development goals</strong></p><ul><li>Immerse obstacles defined by 3D meshes (<a href="https://github.com/JuliaGeometry/Meshing.jl">Meshing.jl</a>)</li><li>Multi-CPU/GPU simulations (https://github.com/WaterLily-jl/WaterLily.jl/pull/141)</li><li>Free-surface physics with (<a href="https://github.com/TzuYaoHuang/WaterLily.jl/blob/master/src/Multiphase.jl">Volume-of-Fluid</a>) or other methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L1">source</a></section></article><h2 id="Types-Methods-and-Functions"><a class="docs-heading-anchor" href="#Types-Methods-and-Functions">Types Methods and Functions</a><a id="Types-Methods-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-Methods-and-Functions" title="Permalink"></a></h2><ul><li><a href="#WaterLily"><code>WaterLily</code></a></li><li><a href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a></li><li><a href="#WaterLily.AbstractPoisson"><code>WaterLily.AbstractPoisson</code></a></li><li><a href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a></li><li><a href="#WaterLily.Bodies"><code>WaterLily.Bodies</code></a></li><li><a href="#WaterLily.Flow"><code>WaterLily.Flow</code></a></li><li><a href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a></li><li><a href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a></li><li><a href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a></li><li><a href="#WaterLily.BC!"><code>WaterLily.BC!</code></a></li><li><a href="#WaterLily.BCTuple"><code>WaterLily.BCTuple</code></a></li><li><a href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a></li><li><a href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a></li><li><a href="#WaterLily.L₂-Tuple{Any}"><code>WaterLily.L₂</code></a></li><li><a href="#WaterLily.accelerate!"><code>WaterLily.accelerate!</code></a></li><li><a href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a></li><li><a href="#WaterLily.check_nthreads-Tuple{Val{1}}"><code>WaterLily.check_nthreads</code></a></li><li><a href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a></li><li><a href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a></li><li><a href="#WaterLily.exitBC!-NTuple{4, Any}"><code>WaterLily.exitBC!</code></a></li><li><a href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a></li><li><a href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N"><code>WaterLily.inside_u</code></a></li><li><a href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a></li><li><a href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a></li><li><a href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a></li><li><a href="#WaterLily.logger"><code>WaterLily.logger</code></a></li><li><a href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a></li><li><a href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure!"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure_sdf!"><code>WaterLily.measure_sdf!</code></a></li><li><a href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a></li><li><a href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a></li><li><a href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a></li><li><a href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a></li><li><a href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a></li><li><a href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a></li><li><a href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a></li><li><a href="#WaterLily.reduce_sdf_map-NTuple{7, Any}"><code>WaterLily.reduce_sdf_map</code></a></li><li><a href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a></li><li><a href="#WaterLily.sdf-Tuple{AutoBody, Any, Any}"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sdf-Tuple{Bodies, Any, Any}"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sdf_map_d-NTuple{4, Any}"><code>WaterLily.sdf_map_d</code></a></li><li><a href="#WaterLily.sim_step!-Tuple{Simulation, Any}"><code>WaterLily.sim_step!</code></a></li><li><a href="#WaterLily.sim_time-Tuple{Simulation}"><code>WaterLily.sim_time</code></a></li><li><a href="#WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a></li><li><a href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a></li><li><a href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a></li><li><a href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a></li><li><a href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a></li><li><a href="#WaterLily.δ-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.δ</code></a></li><li><a href="#WaterLily.λ₂-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.λ₂</code></a></li><li><a href="#WaterLily.ω-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.ω</code></a></li><li><a href="#WaterLily.ω_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.ω_mag</code></a></li><li><a href="#WaterLily.ω_θ-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.ω_θ</code></a></li><li><a href="#WaterLily.∂-NTuple{4, Any}"><code>WaterLily.∂</code></a></li><li><a href="#WaterLily.∇²u-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.∇²u</code></a></li><li><a href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a></li><li><a href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AbstractBody" href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBody</code></pre><p>Immersed body Abstract Type. Any <code>AbstractBody</code> subtype must implement</p><pre><code class="nohighlight hljs">d = sdf(body::AbstractBody, x, t=0)</code></pre><p>and</p><pre><code class="nohighlight hljs">d,n,V = measure(body::AbstractBody, x, t=0, fastd²=Inf)</code></pre><p>where <code>d</code> is the signed distance from <code>x</code> to the body at time <code>t</code>, and <code>n</code> &amp; <code>V</code> are the normal and velocity vectors implied at <code>x</code>. A fast-approximate method can return <code>≈d,zero(x),zero(x)</code> if <code>d^2&gt;fastd²</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Body.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AbstractPoisson" href="#WaterLily.AbstractPoisson"><code>WaterLily.AbstractPoisson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Poisson{N,M}</code></pre><p>Composite type for conservative variable coefficient Poisson equations:</p><pre><code class="nohighlight hljs">∮ds β ∂x/∂n = σ</code></pre><p>The resulting linear system is</p><pre><code class="nohighlight hljs">Ax = [L+D+L&#39;]x = z</code></pre><p>where A is symmetric, block-tridiagonal and extremely sparse. Moreover,  <code>D[I]=-∑ᵢ(L[I,i]+L&#39;[I,i])</code>. This means matrix storage, multiplication, ect can be easily implemented and optimized without external libraries.</p><p>To help iteratively solve the system above, the Poisson structure holds helper arrays for <code>inv(D)</code>, the error <code>ϵ</code>, and residual <code>r=z-Ax</code>. An iterative solution method then estimates the error <code>ϵ=̃A⁻¹r</code> and increments <code>x+=ϵ</code>, <code>r-=Aϵ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AutoBody" href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoBody(sdf,map=(x,t)-&gt;x; compose=true) &lt;: AbstractBody</code></pre><ul><li><code>sdf(x::AbstractVector,t::Real)::Real</code>: signed distance function</li><li><code>map(x::AbstractVector,t::Real)::AbstractVector</code>: coordinate mapping function</li><li><code>compose::Bool=true</code>: Flag for composing <code>sdf=sdf∘map</code></li></ul><p>Implicitly define a geometry by its <code>sdf</code> and optional coordinate <code>map</code>. Note: the <code>map</code> is composed automatically if <code>compose=true</code>, i.e. <code>sdf(x,t) = sdf(map(x,t),t)</code>. Both parameters remain independent otherwise. It can be particularly heplful to set <code>compose=false</code> when adding mulitple bodies together to create a more complex one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Bodies" href="#WaterLily.Bodies"><code>WaterLily.Bodies</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bodies(bodies, ops::AbstractVector)</code></pre><ul><li><code>bodies::Vector{AutoBody}</code>: Vector of <code>AutoBody</code></li><li><code>ops::Vector{Function}</code>: Vector of operators for the superposition of multiple <code>AutoBody</code>s</li></ul><p>Superposes multiple <code>body::AutoBody</code> objects together according to the operators <code>ops</code>. While this can be manually performed by the operators implemented for <code>AutoBody</code>, adding too many bodies can yield a recursion problem of the <code>sdf</code> and <code>map</code> functions not fitting in the stack. This type implements the superposition of bodies by iteration instead of recursion, and the reduction of the <code>sdf</code> and <code>map</code> functions is done on the <code>mesure</code> function, and not before. The operators vector <code>ops</code> specifies the operation to call between two consecutive <code>AutoBody</code>s in the <code>bodies</code> vector. Note that <code>+</code> (or the alias <code>∪</code>) is the only operation supported between <code>Bodies</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Flow" href="#WaterLily.Flow"><code>WaterLily.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flow{D::Int, T::Float, Sf&lt;:AbstractArray{T,D}, Vf&lt;:AbstractArray{T,D+1}, Tf&lt;:AbstractArray{T,D+2}}</code></pre><p>Composite type for a multidimensional immersed boundary flow simulation.</p><p>Flow solves the unsteady incompressible <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The primary variables are the scalar pressure <code>p</code> (an array of dimension <code>D</code>) and the velocity vector field <code>u</code> (an array of dimension <code>D+1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Flow.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.MultiLevelPoisson" href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiLevelPoisson{N,M}</code></pre><p>Composite type used to solve the pressure Poisson equation with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. The only variable is <code>levels</code>, a vector of nested <code>Poisson</code> systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/MultiLevelPoisson.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.NoBody" href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoBody</code></pre><p>Use for a simulation without a body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Body.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Simulation" href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(dims::NTuple, u_BC::Union{NTuple,Function}, L::Number;
           U=norm2(u_BC), Δt=0.25, ν=0., ϵ=1, perdir=()
           uλ::nothing, g=nothing, exitBC=false,
           body::AbstractBody=NoBody(),
           T=Float32, mem=Array)</code></pre><p>Constructor for a WaterLily.jl simulation:</p><ul><li><code>dims</code>: Simulation domain dimensions.</li><li><code>u_BC</code>: Simulation domain velocity boundary conditions, either a         tuple <code>u_BC[i]=uᵢ, i=eachindex(dims)</code>, or a time-varying function <code>f(i,t)</code></li><li><code>L</code>: Simulation length scale.</li><li><code>U</code>: Simulation velocity scale.</li><li><code>Δt</code>: Initial time step.</li><li><code>ν</code>: Scaled viscosity (<code>Re=UL/ν</code>).</li><li><code>g</code>: Domain acceleration, <code>g(i,t)=duᵢ/dt</code></li><li><code>ϵ</code>: BDIM kernel width.</li><li><code>perdir</code>: Domain periodic boundary condition in the <code>(i,)</code> direction.</li><li><code>exitBC</code>: Convective exit boundary condition in the <code>i=1</code> direction.</li><li><code>uλ</code>: Function to generate the initial velocity field.</li><li><code>body</code>: Immersed geometry.</li><li><code>T</code>: Array element type.</li><li><code>mem</code>: memory location. <code>Array</code>, <code>CuArray</code>, <code>ROCm</code> to run on CPU, NVIDIA, or AMD devices, respectively.</li></ul><p>See files in <code>examples</code> folder for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L31-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.BC!" href="#WaterLily.BC!"><code>WaterLily.BC!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BC!(a,A)</code></pre><p>Apply boundary conditions to the ghost cells of a <em>vector</em> field. A Dirichlet condition <code>a[I,i]=A[i]</code> is applied to the vector component <em>normal</em> to the domain boundary. For example <code>aₓ(x)=Aₓ ∀ x ∈ minmax(X)</code>. A zero Neumann condition is applied to the tangential components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.BCTuple" href="#WaterLily.BCTuple"><code>WaterLily.BCTuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BCTuple(U,dt,N)</code></pre><p>Return BC tuple <code>U(i∈1:N, t=sum(dt))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Flow.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d" href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CIj(j,I,jj)</code></pre><p>Replace jᵗʰ component of CartesianIndex with k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Jacobi!-Tuple{Any}" href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobi!(p::Poisson; it=1)</code></pre><p>Jacobi smoother run <code>it</code> times.  Note: This runs for general backends, but is <em>very</em> slow to converge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.L₂-Tuple{Any}" href="#WaterLily.L₂-Tuple{Any}"><code>WaterLily.L₂</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L₂(a)</code></pre><p>L₂ norm of array <code>a</code> excluding ghosts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.accelerate!" href="#WaterLily.accelerate!"><code>WaterLily.accelerate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accelerate!(r,dt,g)</code></pre><p>Add a uniform acceleration <code>gᵢ+dUᵢ/dt</code> at time <code>t=sum(dt)</code> to field <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Flow.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.apply!-Tuple{Any, Any}" href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply!(f, c)</code></pre><p>Apply a vector function <code>f(i,x)</code> to the faces of a uniform staggered array <code>c</code> or a function <code>f(x)</code> to the center of a uniform array <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.check_nthreads-Tuple{Val{1}}" href="#WaterLily.check_nthreads-Tuple{Val{1}}"><code>WaterLily.check_nthreads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_nthreads(::Val{1})</code></pre><p>Check the number of threads available for the Julia session that loads WaterLily. A warning is shown when running in serial (JULIA<em>NUM</em>THREADS=1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curl-Tuple{Any, Any, Any}" href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curl(i,I,u)</code></pre><p>Compute component <code>i</code> of <span>$𝛁×𝐮$</span> at the <strong>edge</strong> of cell <code>I</code>. For example <code>curl(3,CartesianIndex(2,2,2),u)</code> will compute <code>ω₃(x=1.5,y=1.5,z=2)</code> as this edge produces the highest accuracy for this mix of cross derivatives on a staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curvature-Tuple{AbstractMatrix}" href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curvature(A::AbstractMatrix)</code></pre><p>Return <code>H,K</code> the mean and Gaussian curvature from <code>A=hessian(sdf)</code>. <code>K=tr(minor(A))</code> in 3D and <code>K=0</code> in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.exitBC!-NTuple{4, Any}" href="#WaterLily.exitBC!-NTuple{4, Any}"><code>WaterLily.exitBC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exitBC!(u,u⁰,U,Δt)</code></pre><p>Apply a 1D convection scheme to fill the ghost cell on the exit of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside-Tuple{AbstractArray}" href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside(a)</code></pre><p>Return CartesianIndices range excluding a single layer of cells on all boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N" href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any}} where N"><code>WaterLily.inside_u</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside_u(dims,j)</code></pre><p>Return CartesianIndices range excluding the ghost-cells on the boundaries of a <em>vector</em> array on face <code>j</code> with size <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}" href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interp(x::SVector, arr::AbstractArray)

Linear interpolation from array `arr` at index-coordinate `x`.
Note: This routine works for any number of dimensions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m" href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ke(I::CartesianIndex,u,U=0)</code></pre><p>Compute <span>$½∥𝐮-𝐔∥²$</span> at center of cell <code>I</code> where <code>U</code> can be used to subtract a background flow (by default, <code>U=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N" href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loc(i,I) = loc(Ii)</code></pre><p>Location in space of the cell at CartesianIndex <code>I</code> at face <code>i</code>. Using <code>i=0</code> returns the cell center s.t. <code>loc = I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.logger" href="#WaterLily.logger"><code>WaterLily.logger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logger(fname=&quot;WaterLily&quot;)</code></pre><p>Set up a logger to write the pressure solver data to a logging file named <code>WaterLily.log</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!" href="#WaterLily.measure!"><code>WaterLily.measure!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure!(sim::Simulation,t=timeNext(sim))</code></pre><p>Measure a dynamic <code>body</code> to update the <code>flow</code> and <code>pois</code> coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}" href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure!(flow::Flow, body::AbstractBody; t=0, ϵ=1)</code></pre><p>Queries the body geometry to fill the arrays:</p><ul><li><code>flow.μ₀</code>, Zeroth kernel moment</li><li><code>flow.μ₁</code>, First kernel moment scaled by the body normal</li><li><code>flow.V</code>,  Body velocity</li></ul><p>at time <code>t</code> using an immersion kernel of size <code>ϵ</code>.</p><p>See Maertens &amp; Weymouth, doi:<a href="https://doi.org/10.1016/j.cma.2014.09.007">10.1016/j.cma.2014.09.007</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Body.jl#L18-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure-Tuple{AutoBody, Any, Any}" href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d,n,V = measure(body::AutoBody||Bodies,x,t;fastd²=Inf)</code></pre><p>Determine the implicit geometric properties from the <code>sdf</code> and <code>map</code>. The gradient of <code>d=sdf(map(x,t))</code> is used to improve <code>d</code> for pseudo-sdfs. The velocity is determined <em>solely</em> from the optional <code>map</code> function. Skips the <code>n,V</code> calculation when <code>d²&gt;fastd²</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure_sdf!" href="#WaterLily.measure_sdf!"><code>WaterLily.measure_sdf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure_sdf!(a::AbstractArray, body::AbstractBody, t=0)</code></pre><p>Uses <code>sdf(body,x,t)</code> to fill <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Body.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N" href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mom_step!(a::Flow,b::AbstractPoisson)</code></pre><p>Integrate the <code>Flow</code> one time step using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a> and the <code>AbstractPoisson</code> pressure solver to project the velocity onto an incompressible flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Flow.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mult!-Tuple{Poisson, Any}" href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mult!(p::Poisson,x)</code></pre><p>Efficient function for Poisson matrix-vector multiplication.  Fills <code>p.z = p.A x</code> with 0 in the ghost cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.nds-Tuple{Any, Any, Any}" href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nds(body,x,t)</code></pre><p>BDIM-masked surface normal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T" href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pcg!(p::Poisson; it=6)</code></pre><p>Conjugate-Gradient smoother with Jacobi preditioning. Runs at most <code>it</code> iterations,  but will exit early if the Gram-Schmidt update parameter <code>|α| &lt; 1%</code> or <code>|r D⁻¹ r| &lt; 1e-8</code>. Note: This runs for general backends and is the default smoother.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.perBC!-Tuple{Any, Tuple{}}" href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perBC!(a,perdir)</code></pre><p>Apply periodic conditions to the ghost cells of a <em>scalar</em> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L223-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_force-Tuple{Any}" href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_force(sim::Simulation)</code></pre><p>Compute the pressure force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_moment-Tuple{Any, Any}" href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_moment(x₀,sim::Simulation)</code></pre><p>Computes the pressure moment on an immersed body relative to point x₀.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.reduce_sdf_map-NTuple{7, Any}" href="#WaterLily.reduce_sdf_map-NTuple{7, Any}"><code>WaterLily.reduce_sdf_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_sdf_map(sdf_a,map_a,d_a,sdf_b,map_b,d_b,op,x,t)</code></pre><p>Reduces two different <code>sdf</code> and <code>map</code> functions, and <code>d</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.residual!-Tuple{Poisson}" href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual!(p::Poisson)</code></pre><p>Computes the resiual <code>r = z-Ax</code> and corrects it such that <code>r = 0</code> if <code>iD==0</code> which ensures local satisfiability     and  <code>sum(r) = 0</code> which ensures global satisfiability.</p><p>The global correction is done by adjusting all points uniformly,  minimizing the local effect. Other approaches are possible.</p><p>Note: These corrections mean <code>x</code> is not strictly solving <code>Ax=z</code>, but without the corrections, no solution exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf-Tuple{AutoBody, Any, Any}" href="#WaterLily.sdf-Tuple{AutoBody, Any, Any}"><code>WaterLily.sdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = sdf(body::AutoBody,x,t) = body.sdf(x,t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf-Tuple{Bodies, Any, Any}" href="#WaterLily.sdf-Tuple{Bodies, Any, Any}"><code>WaterLily.sdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = sdf(a::Bodies,x,t)</code></pre><p>Computes distance for <code>Bodies</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf_map_d-NTuple{4, Any}" href="#WaterLily.sdf_map_d-NTuple{4, Any}"><code>WaterLily.sdf_map_d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sdf_map_d(ab::Bodies,x,t)</code></pre><p>Returns the <code>sdf</code> and <code>map</code> functions, and the distance <code>d</code> (<code>d=sdf(x,t)</code>) for the <code>Bodies</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/AutoBody.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_step!-Tuple{Simulation, Any}" href="#WaterLily.sim_step!-Tuple{Simulation, Any}"><code>WaterLily.sim_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_step!(sim::Simulation,t_end=sim(time)+Δt;max_steps=typemax(Int),remeasure=true,verbose=false)</code></pre><p>Integrate the simulation <code>sim</code> up to dimensionless time <code>t_end</code>. If <code>remeasure=true</code>, the body is remeasured at every time step. Can be set to <code>false</code> for static geometries to speed up simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_time-Tuple{Simulation}" href="#WaterLily.sim_time-Tuple{Simulation}"><code>WaterLily.sim_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_time(sim::Simulation)</code></pre><p>Return the current dimensionless time of the simulation <code>tU/L</code> where <code>t=sum(Δt)</code>, and <code>U</code>,<code>L</code> are the simulation velocity and length scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/WaterLily.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N" href="#WaterLily.slice-Union{Tuple{N}, Tuple{NTuple{N, T} where T, Any, Any}, Tuple{NTuple{N, T} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice(dims,i,j,low=1)</code></pre><p>Return <code>CartesianIndices</code> range slicing through an array of size <code>dims</code> in dimension <code>j</code> at index <code>i</code>. <code>low</code> optionally sets the lower extent of the range in the other dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L173-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.solver!-Tuple{Poisson}" href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solver!(A::Poisson;log,tol,itmx)</code></pre><p>Approximate iterative solver for the Poisson matrix equation <code>Ax=b</code>.</p><ul><li><code>A</code>: Poisson matrix with working arrays.</li><li><code>A.x</code>: Solution vector. Can start with an initial guess.</li><li><code>A.z</code>: Right-Hand-Side vector. Will be overwritten!</li><li><code>A.n[end]</code>: stores the number of iterations performed.</li><li><code>log</code>: If <code>true</code>, this function returns a vector holding the <code>L₂</code>-norm of the residual at each iteration.</li><li><code>tol</code>: Convergence tolerance on the <code>L₂</code>-norm residual.</li><li><code>itmx</code>: Maximum number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Poisson.jl#L148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.time-Tuple{Flow}" href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time(a::Flow)</code></pre><p>Current flow time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Flow.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.total_force-Tuple{Any}" href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>total_force(sim::Simulation)</p><p>Compute the total force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.viscous_force-Tuple{Any}" href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>viscous_force(sim::Simulation)</p><p>Compute the viscous force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.δ-Union{Tuple{N}, Tuple{Any, Val{N}}} where N" href="#WaterLily.δ-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">δ(i,N::Int)
δ(i,I::CartesianIndex{N}) where {N}</code></pre><p>Return a CartesianIndex of dimension <code>N</code> which is one at index <code>i</code> and zero elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.λ₂-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.λ₂-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.λ₂</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ₂(I::CartesianIndex{3},u)</code></pre><p>λ₂ is a deformation tensor metric to identify vortex cores. See <a href="https://en.wikipedia.org/wiki/Lambda2_method">https://en.wikipedia.org/wiki/Lambda2_method</a> and Jeong, J., &amp; Hussain, F., doi:<a href="https://doi.org/10.1017/S0022112095000462">10.1017/S0022112095000462</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ω-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.ω-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω(I::CartesianIndex{3},u)</code></pre><p>Compute 3-vector <span>$𝛚=𝛁×𝐮$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ω_mag-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.ω_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.ω_mag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω_mag(I::CartesianIndex{3},u)</code></pre><p>Compute <span>$∥𝛚∥$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ω_θ-Tuple{CartesianIndex{3}, Any, Any, Any}" href="#WaterLily.ω_θ-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.ω_θ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω_θ(I::CartesianIndex{3},z,center,u)</code></pre><p>Compute <span>$𝛚⋅𝛉$</span> at the center of cell <code>I</code> where <span>$𝛉$</span> is the azimuth direction around vector <code>z</code> passing through <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.∂-NTuple{4, Any}" href="#WaterLily.∂-NTuple{4, Any}"><code>WaterLily.∂</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂(i,j,I,u)</code></pre><p>Compute <span>$∂uᵢ/∂xⱼ$</span> at center of cell <code>I</code>. Cross terms are computed less accurately than inline terms because of the staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.∇²u-Tuple{CartesianIndex{2}, Any}" href="#WaterLily.∇²u-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.∇²u</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇²u(I::CartesianIndex,u)</code></pre><p>Rate-of-strain tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/Metrics.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@inside-Tuple{Any}" href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@inside &lt;expr&gt;</code></pre><p>Simple macro to automate efficient loops over cells excluding ghosts. For example,</p><pre><code class="nohighlight hljs">@inside p[I] = sum(loc(0,I))</code></pre><p>becomes</p><pre><code class="nohighlight hljs">@loop p[I] = sum(loc(0,I)) over I ∈ inside(p)</code></pre><p>See <a href="#WaterLily.@loop-Tuple"><code>@loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@loop-Tuple" href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@loop &lt;expr&gt; over &lt;I ∈ R&gt;</code></pre><p>Macro to automate fast loops using @simd when running in serial, or KernelAbstractions when running multi-threaded CPU or GPU.</p><p>For example</p><pre><code class="nohighlight hljs">@loop a[I,i] += sum(loc(i,I)) over I ∈ R</code></pre><p>becomes</p><pre><code class="nohighlight hljs">@simd for I ∈ R
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end</code></pre><p>on serial execution, or</p><pre><code class="nohighlight hljs">@kernel function kern(a,i,@Const(I0))
    I ∈ @index(Global,Cartesian)+I0
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end
kern(get_backend(a),64)(a,i,R[1]-oneunit(R[1]),ndrange=size(R))</code></pre><p>when multi-threading on CPU or using CuArrays. Note that <code>get_backend</code> is used on the <em>first</em> variable in <code>expr</code> (<code>a</code> in this example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/979709937daf101f3446f01f9e4e2136170f311c/src/util.jl#L92-L118">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 30 November 2024 16:51">Saturday 30 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
