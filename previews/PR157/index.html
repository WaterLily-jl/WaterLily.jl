<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WaterLily ¬∑ WaterLily.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://WaterLily-jl.github.io/WaterLily.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WaterLily.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>WaterLily</a><ul class="internal"><li><a class="tocitem" href="#Introduction-and-Quickstart"><span>Introduction and Quickstart</span></a></li><li><a class="tocitem" href="#Types-Methods-and-Functions"><span>Types Methods and Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>WaterLily</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WaterLily</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WaterLily"><a class="docs-heading-anchor" href="#WaterLily">WaterLily</a><a id="WaterLily-1"></a><a class="docs-heading-anchor-permalink" href="#WaterLily" title="Permalink"></a></h1><h2 id="Introduction-and-Quickstart"><a class="docs-heading-anchor" href="#Introduction-and-Quickstart">Introduction and Quickstart</a><a id="Introduction-and-Quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-Quickstart" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WaterLily" href="#WaterLily"><code>WaterLily</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p><strong>WaterLily.jl</strong></p><p><a href="https://WaterLily-jl.github.io/WaterLily.jl/dev/"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/WaterLily-jl/WaterLily.jl/actions"><img src="https://github.com/WaterLily-jl/WaterLily.jl/workflows/CI/badge.svg?branch=master&amp;event=push" alt="CI"/></a> <a href="https://codecov.io/gh/WaterLily-jl/WaterLily.jl"><img src="https://codecov.io/gh/WaterLily-jl/WaterLily.jl/branch/master/graph/badge.svg?token=8XYFWKOUFN" alt="codecov"/></a></p><p><img src="examples/julia.gif" alt="Julia flow"/></p><p><strong>Overview</strong></p><p><strong>WaterLily.jl</strong> is a simple and fast fluid simulator written in pure Julia. This project is supported by awesome libraries developed within the Julia scientific community, and it aims to accelerate and enhance fluid simulations. Watch the JuliaCon2024 talk here:</p><p><a href="https://www.youtube.com/live/qru5G5Yp77E?t=29074s"><img src="examples/JuliaCon2024.png" alt="JuliaCon2024 still and link"/></a></p><p>If you have used WaterLily for research, please <strong>cite us</strong>! The following manuscript describes the main features of the solver and provides benchmarking, validation, and profiling results.</p><pre><code class="nohighlight hljs">@misc{WeymouthFont2024,
    title         = {WaterLily.jl: A differentiable and backend-agnostic Julia solver to simulate incompressible viscous flow and dynamic bodies},
    author        = {Gabriel D. Weymouth and Bernat Font},
    url           = {https://arxiv.org/abs/2407.16032},
    eprint        = {2407.16032},
    archivePrefix = {arXiv},
    year          = {2024},
    primaryClass  = {physics.flu-dyn}
}</code></pre><p><strong>Method/capabilities</strong></p><p>WaterLily solves the unsteady incompressible 2D or 3D <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. The pressure Poisson equation is solved with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The solver can run on serial CPU, multi-threaded CPU, or GPU backends.</p><p><strong>Examples</strong></p><p>The user can set the boundary conditions, the initial velocity field, the fluid viscosity (which determines the <a href="https://en.wikipedia.org/wiki/Reynolds_number">Reynolds number</a>), and immerse solid obstacles using a signed distance function. These examples and others are found in the <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples">examples</a> directory.</p><p><strong>Flow over a circle</strong></p><p>We define the size of the simulation domain as <code>n</code><span>$\times$</span><code>m</code> cells. The circle has radius <code>m/8</code> and is centered at <code>(m/2,m/2)</code>. The flow boundary conditions are <code>(U,0)</code>, where we set <code>U=1</code>, and the Reynolds number is <code>Re=U*radius/ŒΩ</code> where <code>ŒΩ</code> (Greek &quot;nu&quot; U+03BD, not Latin lowercase &quot;v&quot;) is the kinematic viscosity of the fluid.</p><pre><code class="language-julia hljs">using WaterLily
function circle(n,m;Re=250,U=1)
    radius, center = m/8, m/2
    body = AutoBody((x,t)-&gt;‚àösum(abs2, x .- center) - radius)
    Simulation((n,m), (U,0), radius; ŒΩ=U*radius/Re, body)
end</code></pre><p>The second to last line defines the circle geometry using a <a href="https://en.wikipedia.org/wiki/Signed_distance_function#Applications">signed distance function</a>. The <code>AutoBody</code> function uses <a href="https://github.com/JuliaDiff/">automatic differentiation</a> to infer the other geometric parameter automatically. Replace the circle&#39;s distance function with any other, and now you have the flow around something else... such as a <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/ThreeD_donut.jl">donut</a> or the <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/TwoD_Julia.jl">Julia logo</a>. Finally, the last line defines the <code>Simulation</code> by passing in parameters we&#39;ve defined.</p><p>Now we can create a simulation (first line) and run it forward in time (third line)</p><pre><code class="language-julia hljs">circ = circle(3*2^6,2^7)
t_end = 10
sim_step!(circ,t_end)</code></pre><p>Note we&#39;ve set <code>n,m</code> to be multiples of powers of 2, which is important when using the (very fast) geometric multi-grid solver. We can now access and plot whatever variables we like. For example, we could print the velocity at <code>I::CartesianIndex</code> using <code>println(circ.flow.u[I])</code> or plot the whole pressure field using</p><pre><code class="language-julia hljs">using Plots
contour(circ.flow.p&#39;)</code></pre><p>A set of <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/src/Metrics.jl">flow metric functions</a> have been implemented and the examples use these to make gifs such as the one above.</p><p><strong>3D Taylor Green Vortex</strong></p><p>The three-dimensional <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/ThreeD_TaylorGreenVortex.jl">Taylor Green Vortex</a> demonstrates many of the other available simulation options. First, you can simulate a non-trivial initial velocity field by passing in a vector function <code>uŒª(i,xyz)</code> where <code>i ‚àà (1,2,3)</code> indicates the velocity component <code>u·µ¢</code> and <code>xyz=[x,y,z]</code> is the position vector.</p><pre><code class="language-julia hljs">function TGV(; pow=6, Re=1e5, T=Float64, mem=Array)
    # Define vortex size, velocity, viscosity
    L = 2^pow; U = 1; ŒΩ = U*L/Re
    # Taylor-Green-Vortex initial velocity field
    function uŒª(i,xyz)
        x,y,z = @. (xyz-1.5)*œÄ/L               # scaled coordinates
        i==1 &amp;&amp; return -U*sin(x)*cos(y)*cos(z) # u_x
        i==2 &amp;&amp; return  U*cos(x)*sin(y)*cos(z) # u_y
        return 0.                              # u_z
    end
    # Initialize simulation
    return Simulation((L, L, L), (0, 0, 0), L; U, uŒª, ŒΩ, T, mem)
end</code></pre><p>This example also demonstrates the floating point type (<code>T=Float64</code>) and array memory type (<code>mem=Array</code>) options. For example, to run on an NVIDIA GPU we only need to import the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> library and initialize the <code>Simulation</code> memory on that device.</p><pre><code class="language-julia hljs">import CUDA
@assert CUDA.functional()
vortex = TGV(T=Float32,mem=CUDA.CuArray)
sim_step!(vortex,1)</code></pre><p>For an AMD GPU, use <code>import AMDGPU</code> and <code>mem=AMDGPU.ROCArray</code>. Note that Julia 1.9 is required for AMD GPUs.</p><p><strong>Moving bodies</strong></p><p><img src="examples/hover.gif" alt="Flapping line segment flow"/></p><p>You can simulate moving bodies in WaterLily by passing a coordinate <code>map</code> to <code>AutoBody</code> in addition to the <code>sdf</code>.</p><pre><code class="language-julia hljs">using StaticArrays
function hover(L=2^5;Re=250,U=1,amp=œÄ/4,œµ=0.5,thk=2œµ+‚àö2)
    # Line segment SDF
    function sdf(x,t)
        y = x .- SA[0,clamp(x[2],-L/2,L/2)]
        ‚àösum(abs2,y)-thk/2
    end
    # Oscillating motion and rotation
    function map(x,t)
        Œ± = amp*cos(t*U/L); R = SA[cos(Œ±) sin(Œ±); -sin(Œ±) cos(Œ±)]
        R * (x - SA[3L-L*sin(t*U/L),4L])
    end
    Simulation((6L,6L),(0,0),L;U,ŒΩ=U*L/Re,body=AutoBody(sdf,map),œµ)
end</code></pre><p><a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/TwoD_hover.jl">In this example</a>, the <code>sdf</code> function defines a line segment from <code>-L/2 ‚â§ x[2] ‚â§ L/2</code> with a thickness <code>thk</code>. To make the line segment move, we define a coordinate transformation function <code>map(x,t)</code>. In this example, the coordinate <code>x</code> is shifted by <code>(3L,4L)</code> at time <code>t=0</code>, which moves the center of the segment to this point. However, the horizontal shift varies harmonically in time, sweeping the segment left and right during the simulation. The example also rotates the segment using the rotation matrix <code>R = [cos(Œ±) sin(Œ±); -sin(Œ±) cos(Œ±)]</code> where the angle <code>Œ±</code> is also varied harmonically. The combined result is a thin flapping line, similar to a cross-section of a hovering insect wing.</p><p>One important thing to note here is the use of <code>StaticArrays</code> to define the <code>sdf</code> and <code>map</code>. This speeds up the simulation since it eliminates allocations at every grid cell and time step.</p><p><strong>Circle inside an oscillating flow</strong></p><p><img src="examples/oscillating.gif" alt="Oscillating flow"/></p><p>This <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/TwoD_oscillatingFlowOverCircle.jl">example</a> demonstrates a 2D oscillating periodic flow over a circle.</p><pre><code class="language-julia hljs">function circle(n,m;Re=250,U=1)
    # define a circle at the domain center
    radius = m/8
    body = AutoBody((x,t)-&gt;‚àösum(abs2, x .- (n/2,m/2)) - radius)

    # define time-varying body force `g` and periodic direction `perdir`
    accelScale, timeScale = U^2/2radius, radius/U
    g(i,t) = i==1 ? -2accelScale*sin(t/timeScale) : 0
    Simulation((n,m), (U,0), radius; ŒΩ=U*radius/Re, body, g, perdir=(1,))
end</code></pre><p>The <code>g</code> argument accepts a function with direction (<code>i</code>) and time (<code>t</code>) arguments. This allows you to create a spatially uniform body force with variations over time. In this example, the function adds a sinusoidal force in the &quot;x&quot; direction <code>i=1</code>, and nothing to the other directions.</p><p>The <code>perdir</code> argument is a tuple that specifies the directions to which periodic boundary conditions should be applied. Any number of directions may be defined as periodic, but in this example only the <code>i=1</code> direction is used allowing the flow to accelerate freely in this direction.</p><p><strong>Accelerating reference frame</strong></p><p>WaterLily gives the possibility to set up a <code>Simulation</code> using time-varying boundary conditions for the velocity field, as demonstrated in <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/TwoD_SlowStartCircle.jl">this example</a>. This can be used to simulate a flow in an accelerating reference frame. The following example demonstrates how to set up a <code>Simulation</code> with a time-varying velocity field.</p><pre><code class="language-julia hljs">using WaterLily
# define time-varying velocity boundary conditions
Ut(i,t::T;a0=0.5) where T = i==1 ? convert(T, a0*t) : zero(T)
# pass that to the function that creates the simulation
sim = Simulation((256,256), Ut, 32)</code></pre><p>The <code>Ut</code> function is used to define the time-varying velocity field. In this example, the velocity in the &quot;x&quot; direction is set to <code>a0*t</code> where <code>a0</code> is the acceleration of the reference frame. The <code>Simulation</code> function is then called with the <code>Ut</code> function as the second argument. The simulation will then run with the time-varying velocity field.</p><p><strong>Periodic and convective boundary conditions</strong></p><p>In addition to the standard free-slip (or reflective) boundary conditions, WaterLily also supports periodic boundary conditions, as demonstrated in <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/TwoD_circle_periodicBC_convectiveBC.jl">this example</a>. For instance, to set up a <code>Simulation</code> with periodic boundary conditions in the &quot;y&quot; direction the <code>perdir=(2,)</code> keyword argument should be passed</p><pre><code class="language-julia hljs">using WaterLily,StaticArrays

# sdf an map for a moving circle in y-direction
function sdf(x,t)
    norm2(SA[x[1]-192,mod(x[2]-384,384)-192])-32
end
function map(x,t)
    x.-SA[0.,t/2]
end

# make a body
body = AutoBody(sdf, map)

# y-periodic boundary conditions
Simulation((512,384), (1,0), 32; body, perdir=(2,))</code></pre><p>Additionally, the flag <code>exitBC=true</code> can be passed to the <code>Simulation</code> function to enable convective boundary conditions. This will apply a 1D convective exit in the <strong><code>x</code></strong> direction (currently, only the <code>x</code> direction is supported for the convective outlet BC). The <code>exitBC</code> flag is set to <code>false</code> by default. In this case, the boundary condition is set to the corresponding value of the <code>u_BC</code> vector specified when constructing the <code>Simulation</code>.</p><pre><code class="language-julia hljs">using WaterLily

# make a body
body = AutoBody(sdf, map)

# y-periodic boundary conditions
Simulation((512,384), u_BC=(1,0), L=32; body, exitBC=true)</code></pre><p><strong>Writing to a VTK file</strong></p><p>The following <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/ThreeD_cylinder_vtk_restart.jl">example</a> demonstrates how to write simulation data to a <code>.pvd</code> file using the <code>WriteVTK</code> package and the WaterLily <code>vtkwriter</code> function. The simplest writer can be instantiated with</p><pre><code class="language-julia hljs">using WaterLily,WriteVTK

# make a sim
sim = make_sim(...)

# make a writer
writer = vtkwriter(&quot;simple_writer&quot;)

# write the data
write!(writer,sim)

# don&#39;t forget to close the file
close(writer)</code></pre><p>This would write the velocity and pressure fields to a file named <code>simmple_writer.pvd</code>. The <code>vtkwriter</code> function can also take a dictionary of custom attributes to write to the file. For example, the following code can be run to write the body signed-distance function and Œª‚ÇÇ fields to the file</p><pre><code class="language-julia hljs">using WaterLily,WriteVTK

# make a writer with some attributes, need to output to CPU array to save file (|&gt; Array)
velocity(a::Simulation) = a.flow.u |&gt; Array;
pressure(a::Simulation) = a.flow.p |&gt; Array;
_body(a::Simulation) = (measure_sdf!(a.flow.œÉ, a.body, WaterLily.time(a));
                                     a.flow.œÉ |&gt; Array;)
lamda(a::Simulation) = (@inside a.flow.œÉ[I] = WaterLily.Œª‚ÇÇ(I, a.flow.u);
                        a.flow.œÉ |&gt; Array;)

# map field names to values in the file
custom_attrib = Dict(
    &quot;Velocity&quot; =&gt; velocity,
    &quot;Pressure&quot; =&gt; pressure,
    &quot;Body&quot; =&gt; _body,
    &quot;Lambda&quot; =&gt; lamda
)

# make the writer
writer = vtkWriter(&quot;advanced_writer&quot;; attrib=custom_attrib)
...
close(writer)</code></pre><p>The functions that are passed to the <code>attrib</code> (custom attributes) must follow the same structure as what is shown in this example, that is, given a <code>Simulation</code>, return an N-dimensional (scalar or vector) field. The <code>vtkwriter</code> function will automatically write the data to a <code>.pvd</code> file, which can be read by ParaView. The prototype for the <code>vtkwriter</code> function is:</p><pre><code class="language-julia hljs"># prototype vtk writer function
custom_vtk_function(a::Simulation) = ... |&gt; Array</code></pre><p>where <code>...</code> should be replaced with the code that generates the field you want to write to the file. The piping to a (CPU) <code>Array</code> is necessary to ensure that the data is written to the CPU before being written to the file for GPU simulations.</p><p><strong>Restarting from a VTK file</strong></p><p>The restart of a simulation from a VTK file is demonstrated in <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/ThreeD_cylinder_vtk_restart.jl">this example</a>. The <code>ReadVTK</code> package is used to read simulation data from a <code>.pvd</code> file. This <code>.pvd</code> <strong>must</strong> have been written with the <code>vtkwriter</code> function and <strong>must</strong> contain at least the <code>velocity</code> and <code>pressure</code> fields. The following example demonstrates how to restart a simulation from a <code>.pvd</code> file using the <code>ReadVTK</code> package and the WaterLily <code>vtkreader</code> function</p><pre><code class="language-julia hljs">using WaterLily,ReadVTK
sim = make_sim(...)
# restart the simulation
writer = restart_sim!(sim; fname=&quot;file_restart.pvd&quot;)

# append sim data to the file used for restart
write!(writer, sim)

# don&#39;t forget to close the file
close(writer)</code></pre><p>Internally, this function reads the last file in the <code>.pvd</code> file and use that to set the <code>velocity</code> and <code>pressure</code> fields in the simulation. The <code>sim_time</code> is also set to the last value saved in the <code>.pvd</code> file. The function also returns a <code>vtkwriter</code> that will append the new data to the file used to restart the simulation. <strong>Note</strong> that the simulation object <code>sim</code> that will be filled must be identical to the one saved to the file for this restart to work, that is, the same size, same body, etc.</p><p><strong>Multi-threading and GPU backends</strong></p><p>WaterLily uses <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> to multi-thread on CPU and run on GPU backends. The implementation method and speed-up are documented in our <a href="https://arxiv.org/abs/2407.16032">preprint</a>. In summary, a single macro <code>WaterLily.@loop</code> is used for nearly every loop in the code base, and this uses KernelAbstractactions to generate optimized code for each back-end. The speed-up with respect to a serial (single thread) execution is more pronounce for large simulations, and we have measure up to x8 speedups when multi-threading on an Intel Xeon Platinum 8460Y @ 2.3GHz backend, and up to 200x speedup on an NVIDIA Hopper H100 64GB HBM2 GPU. When maximizing the GPU load, a cost of 1.44 nano-seconds has been measured per degree of freedom and time step.</p><p>Note that multi-threading requires <em>starting</em> Julia with the <code>--threads</code> argument, see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">the multi-threading section</a> of the manual. If you are running Julia with multiple threads, KernelAbstractions will detect this and multi-thread the loops automatically. As in the Taylor-Green-Vortex examples above, running on a GPU requires initializing the <code>Simulation</code> memory on the GPU, and care needs to be taken to move the data back to the CPU for visualization. See <a href="https://github.com/WaterLily-jl/WaterLily.jl/blob/master/examples/ThreeD_jelly.jl">jelly fish</a> for another non-trivial example.</p><p>Finally, KernelAbstractions does incur some CPU allocations for every loop, but other than this <code>sim_step!</code> is completely non-allocating. This is one reason why the speed-up improves as the size of the simulation increases.</p><p><strong>Contributing and issues</strong></p><p>We always appreciate new contributions, so please <a href="https://github.com/WaterLily-jl/WaterLily.jl/compare">submit a pull request</a> with your changes and help us make WaterLily even better! Note that contributions need to be submitted together with benchmark results - WaterLily should always be fast! ;) For this, we have a <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks">fully automated benchmarking suite</a> that conducts performance tests. In short, to compare your changes with the latest WaterLily, clone the that repo and run the benchmarks with</p><pre><code class="language-sh hljs">git clone https://github.com/WaterLily-jl/WaterLily-Benchmarks &amp;&amp; cd WaterLily-Benchmarks
sh benchmark.sh -wd &quot;&lt;your/waterlily/path&gt;&quot; -w &quot;&lt;your_waterlily_branch&gt; master&quot;
julia --project compare.jl</code></pre><p>This will run benchmarks for CPU and GPU backends. If you do not have a GPU, simply pass <code>-b &quot;Array&quot;</code> when runnning <code>benchmark.sh</code>. More information on the benchmark suite is available in that <a href="https://github.com/WaterLily-jl/WaterLily-Benchmarks/blob/main/README.md">README</a>.</p><p>Of course, ideas, suggestions, and questions are welcome too! Please <a href="https://github.com/WaterLily-jl/WaterLily.jl/issues/new/choose">raise an issue</a> to address any of these.</p><p><strong>Development goals</strong></p><ul><li>Immerse obstacles defined by 3D meshes using <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics</a>.</li><li>Multi-CPU/GPU simulations.</li><li>Free-surface physics with Volume-of-Fluid or Level-Set.</li><li>External potential-flow domain boundary conditions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L1">source</a></section></article><h2 id="Types-Methods-and-Functions"><a class="docs-heading-anchor" href="#Types-Methods-and-Functions">Types Methods and Functions</a><a id="Types-Methods-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-Methods-and-Functions" title="Permalink"></a></h2><ul><li><a href="#WaterLily"><code>WaterLily</code></a></li><li><a href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a></li><li><a href="#WaterLily.AbstractPoisson"><code>WaterLily.AbstractPoisson</code></a></li><li><a href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a></li><li><a href="#WaterLily.Bodies"><code>WaterLily.Bodies</code></a></li><li><a href="#WaterLily.Flow"><code>WaterLily.Flow</code></a></li><li><a href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a></li><li><a href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a></li><li><a href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a></li><li><a href="#WaterLily.BC!"><code>WaterLily.BC!</code></a></li><li><a href="#WaterLily.BCTuple"><code>WaterLily.BCTuple</code></a></li><li><a href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a></li><li><a href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a></li><li><a href="#WaterLily.L‚ÇÇ-Tuple{Any}"><code>WaterLily.L‚ÇÇ</code></a></li><li><a href="#WaterLily.accelerate!"><code>WaterLily.accelerate!</code></a></li><li><a href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a></li><li><a href="#WaterLily.check_nthreads-Tuple{Val{1}}"><code>WaterLily.check_nthreads</code></a></li><li><a href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a></li><li><a href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a></li><li><a href="#WaterLily.exitBC!-NTuple{4, Any}"><code>WaterLily.exitBC!</code></a></li><li><a href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a></li><li><a href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any}} where N"><code>WaterLily.inside_u</code></a></li><li><a href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a></li><li><a href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a></li><li><a href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a></li><li><a href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a></li><li><a href="#WaterLily.measure!"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a></li><li><a href="#WaterLily.measure_sdf!"><code>WaterLily.measure_sdf!</code></a></li><li><a href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a></li><li><a href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a></li><li><a href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a></li><li><a href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a></li><li><a href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a></li><li><a href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a></li><li><a href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a></li><li><a href="#WaterLily.reduce_sdf_map-NTuple{7, Any}"><code>WaterLily.reduce_sdf_map</code></a></li><li><a href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a></li><li><a href="#WaterLily.sdf-Tuple{AutoBody, Any, Any}"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sdf-Tuple{Bodies, Any, Any}"><code>WaterLily.sdf</code></a></li><li><a href="#WaterLily.sdf_map_d-NTuple{4, Any}"><code>WaterLily.sdf_map_d</code></a></li><li><a href="#WaterLily.sim_step!-Tuple{Simulation, Any}"><code>WaterLily.sim_step!</code></a></li><li><a href="#WaterLily.sim_time-Tuple{Simulation}"><code>WaterLily.sim_time</code></a></li><li><a href="#WaterLily.slice-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a></li><li><a href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a></li><li><a href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a></li><li><a href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a></li><li><a href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a></li><li><a href="#WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.Œ¥</code></a></li><li><a href="#WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.Œª‚ÇÇ</code></a></li><li><a href="#WaterLily.œâ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ</code></a></li><li><a href="#WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ_mag</code></a></li><li><a href="#WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.œâ_Œ∏</code></a></li><li><a href="#WaterLily.‚àÇ-NTuple{4, Any}"><code>WaterLily.‚àÇ</code></a></li><li><a href="#WaterLily.‚àá¬≤u-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.‚àá¬≤u</code></a></li><li><a href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a></li><li><a href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AbstractBody" href="#WaterLily.AbstractBody"><code>WaterLily.AbstractBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBody</code></pre><p>Immersed body Abstract Type. Any <code>AbstractBody</code> subtype must implement</p><pre><code class="nohighlight hljs">d = sdf(body::AbstractBody, x, t=0)</code></pre><p>and</p><pre><code class="nohighlight hljs">d,n,V = measure(body::AbstractBody, x, t=0, fastd¬≤=Inf)</code></pre><p>where <code>d</code> is the signed distance from <code>x</code> to the body at time <code>t</code>, and <code>n</code> &amp; <code>V</code> are the normal and velocity vectors implied at <code>x</code>. A fast-approximate method can return <code>‚âàd,zero(x),zero(x)</code> if <code>d^2&gt;fastd¬≤</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Body.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AbstractPoisson" href="#WaterLily.AbstractPoisson"><code>WaterLily.AbstractPoisson</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Poisson{N,M}</code></pre><p>Composite type for conservative variable coefficient Poisson equations:</p><pre><code class="nohighlight hljs">‚àÆds Œ≤ ‚àÇx/‚àÇn = œÉ</code></pre><p>The resulting linear system is</p><pre><code class="nohighlight hljs">Ax = [L+D+L&#39;]x = z</code></pre><p>where A is symmetric, block-tridiagonal and extremely sparse. Moreover,  <code>D[I]=-‚àë·µ¢(L[I,i]+L&#39;[I,i])</code>. This means matrix storage, multiplication, ect can be easily implemented and optimized without external libraries.</p><p>To help iteratively solve the system above, the Poisson structure holds helper arrays for <code>inv(D)</code>, the error <code>œµ</code>, and residual <code>r=z-Ax</code>. An iterative solution method then estimates the error <code>œµ=ÃÉA‚Åª¬πr</code> and increments <code>x+=œµ</code>, <code>r-=Aœµ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.AutoBody" href="#WaterLily.AutoBody"><code>WaterLily.AutoBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoBody(sdf,map=(x,t)-&gt;x; compose=true) &lt;: AbstractBody</code></pre><ul><li><code>sdf(x::AbstractVector,t::Real)::Real</code>: signed distance function</li><li><code>map(x::AbstractVector,t::Real)::AbstractVector</code>: coordinate mapping function</li><li><code>compose::Bool=true</code>: Flag for composing <code>sdf=sdf‚àòmap</code></li></ul><p>Implicitly define a geometry by its <code>sdf</code> and optional coordinate <code>map</code>. Note: the <code>map</code> is composed automatically if <code>compose=true</code>, i.e. <code>sdf(x,t) = sdf(map(x,t),t)</code>. Both parameters remain independent otherwise. It can be particularly heplful to set <code>compose=false</code> when adding mulitple bodies together to create a more complex one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Bodies" href="#WaterLily.Bodies"><code>WaterLily.Bodies</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bodies(bodies, ops::AbstractVector)</code></pre><ul><li><code>bodies::Vector{AutoBody}</code>: Vector of <code>AutoBody</code></li><li><code>ops::Vector{Function}</code>: Vector of operators for the superposition of multiple <code>AutoBody</code>s</li></ul><p>Superposes multiple <code>body::AutoBody</code> objects together according to the operators <code>ops</code>. While this can be manually performed by the operators implemented for <code>AutoBody</code>, adding too many bodies can yield a recursion problem of the <code>sdf</code> and <code>map</code> functions not fitting in the stack. This type implements the superposition of bodies by iteration instead of recursion, and the reduction of the <code>sdf</code> and <code>map</code> functions is done on the <code>mesure</code> function, and not before. The operators vector <code>ops</code> specifies the operation to call between two consecutive <code>AutoBody</code>s in the <code>bodies</code> vector. Note that <code>+</code> (or the alias <code>‚à™</code>) is the only operation supported between <code>Bodies</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Flow" href="#WaterLily.Flow"><code>WaterLily.Flow</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flow{D::Int, T::Float, Sf&lt;:AbstractArray{T,D}, Vf&lt;:AbstractArray{T,D+1}, Tf&lt;:AbstractArray{T,D+2}}</code></pre><p>Composite type for a multidimensional immersed boundary flow simulation.</p><p>Flow solves the unsteady incompressible <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid. Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>. The primary variables are the scalar pressure <code>p</code> (an array of dimension <code>D</code>) and the velocity vector field <code>u</code> (an array of dimension <code>D+1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Flow.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.MultiLevelPoisson" href="#WaterLily.MultiLevelPoisson"><code>WaterLily.MultiLevelPoisson</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiLevelPoisson{N,M}</code></pre><p>Composite type used to solve the pressure Poisson equation with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method. The only variable is <code>levels</code>, a vector of nested <code>Poisson</code> systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/MultiLevelPoisson.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.NoBody" href="#WaterLily.NoBody"><code>WaterLily.NoBody</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoBody</code></pre><p>Use for a simulation without a body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Body.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Simulation" href="#WaterLily.Simulation"><code>WaterLily.Simulation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(dims::NTuple, u_BC::Union{NTuple,Function}, L::Number;
           U=norm2(u_BC), Œît=0.25, ŒΩ=0., œµ=1, perdir=()
           uŒª::nothing, g=nothing, exitBC=false,
           body::AbstractBody=NoBody(),
           T=Float32, mem=Array)</code></pre><p>Constructor for a WaterLily.jl simulation:</p><ul><li><code>dims</code>: Simulation domain dimensions.</li><li><code>u_BC</code>: Simulation domain velocity boundary conditions, either a         tuple <code>u_BC[i]=u·µ¢, i=eachindex(dims)</code>, or a time-varying function <code>f(i,t)</code></li><li><code>L</code>: Simulation length scale.</li><li><code>U</code>: Simulation velocity scale.</li><li><code>Œît</code>: Initial time step.</li><li><code>ŒΩ</code>: Scaled viscosity (<code>Re=UL/ŒΩ</code>).</li><li><code>g</code>: Domain acceleration, <code>g(i,t)=du·µ¢/dt</code></li><li><code>œµ</code>: BDIM kernel width.</li><li><code>perdir</code>: Domain periodic boundary condition in the <code>(i,)</code> direction.</li><li><code>exitBC</code>: Convective exit boundary condition in the <code>i=1</code> direction.</li><li><code>uŒª</code>: Function to generate the initial velocity field.</li><li><code>body</code>: Immersed geometry.</li><li><code>T</code>: Array element type.</li><li><code>mem</code>: memory location. <code>Array</code>, <code>CuArray</code>, <code>ROCm</code> to run on CPU, NVIDIA, or AMD devices, respectively.</li></ul><p>See files in <code>examples</code> folder for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L31-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.BC!" href="#WaterLily.BC!"><code>WaterLily.BC!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BC!(a,A)</code></pre><p>Apply boundary conditions to the ghost cells of a <em>vector</em> field. A Dirichlet condition <code>a[I,i]=A[i]</code> is applied to the vector component <em>normal</em> to the domain boundary. For example <code>a‚Çì(x)=A‚Çì ‚àÄ x ‚àà minmax(X)</code>. A zero Neumann condition is applied to the tangential components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.BCTuple" href="#WaterLily.BCTuple"><code>WaterLily.BCTuple</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BCTuple(U,dt,N)</code></pre><p>Return BC tuple <code>U(i‚àà1:N, t=sum(dt))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Flow.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d" href="#WaterLily.CIj-Union{Tuple{d}, Tuple{Any, CartesianIndex{d}, Any}} where d"><code>WaterLily.CIj</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CIj(j,I,jj)</code></pre><p>Replace j·µó ∞ component of CartesianIndex with k</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Jacobi!-Tuple{Any}" href="#WaterLily.Jacobi!-Tuple{Any}"><code>WaterLily.Jacobi!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Jacobi!(p::Poisson; it=1)</code></pre><p>Jacobi smoother run <code>it</code> times.  Note: This runs for general backends, but is <em>very</em> slow to converge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.L‚ÇÇ-Tuple{Any}" href="#WaterLily.L‚ÇÇ-Tuple{Any}"><code>WaterLily.L‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L‚ÇÇ(a)</code></pre><p>L‚ÇÇ norm of array <code>a</code> excluding ghosts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.accelerate!" href="#WaterLily.accelerate!"><code>WaterLily.accelerate!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accelerate!(r,dt,g)</code></pre><p>Add a uniform acceleration <code>g·µ¢+dU·µ¢/dt</code> at time <code>t=sum(dt)</code> to field <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Flow.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.apply!-Tuple{Any, Any}" href="#WaterLily.apply!-Tuple{Any, Any}"><code>WaterLily.apply!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply!(f, c)</code></pre><p>Apply a vector function <code>f(i,x)</code> to the faces of a uniform staggered array <code>c</code> or a function <code>f(x)</code> to the center of a uniform array <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.check_nthreads-Tuple{Val{1}}" href="#WaterLily.check_nthreads-Tuple{Val{1}}"><code>WaterLily.check_nthreads</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_nthreads(::Val{1})</code></pre><p>Check the number of threads available for the Julia session that loads WaterLily. A warning is shown when running in serial (JULIA<em>NUM</em>THREADS=1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curl-Tuple{Any, Any, Any}" href="#WaterLily.curl-Tuple{Any, Any, Any}"><code>WaterLily.curl</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curl(i,I,u)</code></pre><p>Compute component <code>i</code> of <span>$ùõÅ√óùêÆ$</span> at the <strong>edge</strong> of cell <code>I</code>. For example <code>curl(3,CartesianIndex(2,2,2),u)</code> will compute <code>œâ‚ÇÉ(x=1.5,y=1.5,z=2)</code> as this edge produces the highest accuracy for this mix of cross derivatives on a staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.curvature-Tuple{AbstractMatrix}" href="#WaterLily.curvature-Tuple{AbstractMatrix}"><code>WaterLily.curvature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curvature(A::AbstractMatrix)</code></pre><p>Return <code>H,K</code> the mean and Gaussian curvature from <code>A=hessian(sdf)</code>. <code>K=tr(minor(A))</code> in 3D and <code>K=0</code> in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.exitBC!-NTuple{4, Any}" href="#WaterLily.exitBC!-NTuple{4, Any}"><code>WaterLily.exitBC!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exitBC!(u,u‚Å∞,U,Œît)</code></pre><p>Apply a 1D convection scheme to fill the ghost cell on the exit of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside-Tuple{AbstractArray}" href="#WaterLily.inside-Tuple{AbstractArray}"><code>WaterLily.inside</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside(a)</code></pre><p>Return CartesianIndices range excluding a single layer of cells on all boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.inside_u-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any}} where N" href="#WaterLily.inside_u-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any}} where N"><code>WaterLily.inside_u</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inside_u(dims,j)</code></pre><p>Return CartesianIndices range excluding the ghost-cells on the boundaries of a <em>vector</em> array on face <code>j</code> with size <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}" href="#WaterLily.interp-Union{Tuple{T}, Tuple{D}, Tuple{StaticArraysCore.SVector{D}, AbstractArray{T, D}}} where {D, T}"><code>WaterLily.interp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interp(x::SVector, arr::AbstractArray)

Linear interpolation from array `arr` at index-coordinate `x`.
Note: This routine works for any number of dimensions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m" href="#WaterLily.ke-Union{Tuple{m}, Tuple{CartesianIndex{m}, Any}, Tuple{CartesianIndex{m}, Any, Any}} where m"><code>WaterLily.ke</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ke(I::CartesianIndex,u,U=0)</code></pre><p>Compute <span>$¬Ω‚à•ùêÆ-ùêî‚à•¬≤$</span> at center of cell <code>I</code> where <code>U</code> can be used to subtract a background flow (by default, <code>U=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N" href="#WaterLily.loc-Union{Tuple{N}, Tuple{Any, CartesianIndex{N}}, Tuple{Any, CartesianIndex{N}, Any}} where N"><code>WaterLily.loc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loc(i,I) = loc(Ii)</code></pre><p>Location in space of the cell at CartesianIndex <code>I</code> at face <code>i</code>. Using <code>i=0</code> returns the cell center s.t. <code>loc = I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!" href="#WaterLily.measure!"><code>WaterLily.measure!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure!(sim::Simulation,t=timeNext(sim))</code></pre><p>Measure a dynamic <code>body</code> to update the <code>flow</code> and <code>pois</code> coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}" href="#WaterLily.measure!-Union{Tuple{T}, Tuple{N}, Tuple{Flow{N, T, Sf, Vf, Tf} where {Sf&lt;:(AbstractArray{T}), Vf&lt;:(AbstractArray{T}), Tf&lt;:(AbstractArray{T})}, AbstractBody}} where {N, T}"><code>WaterLily.measure!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure!(flow::Flow, body::AbstractBody; t=0, œµ=1)</code></pre><p>Queries the body geometry to fill the arrays:</p><ul><li><code>flow.Œº‚ÇÄ</code>, Zeroth kernel moment</li><li><code>flow.Œº‚ÇÅ</code>, First kernel moment scaled by the body normal</li><li><code>flow.V</code>,  Body velocity</li></ul><p>at time <code>t</code> using an immersion kernel of size <code>œµ</code>.</p><p>See Maertens &amp; Weymouth, doi:<a href="https://doi.org/10.1016/j.cma.2014.09.007">10.1016/j.cma.2014.09.007</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Body.jl#L18-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure-Tuple{AutoBody, Any, Any}" href="#WaterLily.measure-Tuple{AutoBody, Any, Any}"><code>WaterLily.measure</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d,n,V = measure(body::AutoBody||Bodies,x,t;fastd¬≤=Inf)</code></pre><p>Determine the implicit geometric properties from the <code>sdf</code> and <code>map</code>. The gradient of <code>d=sdf(map(x,t))</code> is used to improve <code>d</code> for pseudo-sdfs. The velocity is determined <em>solely</em> from the optional <code>map</code> function. Skips the <code>n,V</code> calculation when <code>d¬≤&gt;fastd¬≤</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.measure_sdf!" href="#WaterLily.measure_sdf!"><code>WaterLily.measure_sdf!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure_sdf!(a::AbstractArray, body::AbstractBody, t=0)</code></pre><p>Uses <code>sdf(body,x,t)</code> to fill <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Body.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N" href="#WaterLily.mom_step!-Union{Tuple{N}, Tuple{Flow{N, T} where T, AbstractPoisson}} where N"><code>WaterLily.mom_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mom_step!(a::Flow,b::AbstractPoisson)</code></pre><p>Integrate the <code>Flow</code> one time step using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a> and the <code>AbstractPoisson</code> pressure solver to project the velocity onto an incompressible flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Flow.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.mult!-Tuple{Poisson, Any}" href="#WaterLily.mult!-Tuple{Poisson, Any}"><code>WaterLily.mult!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mult!(p::Poisson,x)</code></pre><p>Efficient function for Poisson matrix-vector multiplication.  Fills <code>p.z = p.A x</code> with 0 in the ghost cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.nds-Tuple{Any, Any, Any}" href="#WaterLily.nds-Tuple{Any, Any, Any}"><code>WaterLily.nds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nds(body,x,t)</code></pre><p>BDIM-masked surface normal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T" href="#WaterLily.pcg!-Union{Tuple{Poisson{T, S, V} where {S&lt;:(AbstractArray{T}), V&lt;:(AbstractArray{T})}}, Tuple{T}} where T"><code>WaterLily.pcg!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pcg!(p::Poisson; it=6)</code></pre><p>Conjugate-Gradient smoother with Jacobi preditioning. Runs at most <code>it</code> iterations,  but will exit early if the Gram-Schmidt update parameter <code>|Œ±| &lt; 1%</code> or <code>|r D‚Åª¬π r| &lt; 1e-8</code>. Note: This runs for general backends and is the default smoother.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.perBC!-Tuple{Any, Tuple{}}" href="#WaterLily.perBC!-Tuple{Any, Tuple{}}"><code>WaterLily.perBC!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perBC!(a,perdir)</code></pre><p>Apply periodic conditions to the ghost cells of a <em>scalar</em> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L200-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_force-Tuple{Any}" href="#WaterLily.pressure_force-Tuple{Any}"><code>WaterLily.pressure_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_force(sim::Simulation)</code></pre><p>Compute the pressure force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.pressure_moment-Tuple{Any, Any}" href="#WaterLily.pressure_moment-Tuple{Any, Any}"><code>WaterLily.pressure_moment</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure_moment(x‚ÇÄ,sim::Simulation)</code></pre><p>Computes the pressure moment on an immersed body relative to point x‚ÇÄ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.reduce_sdf_map-NTuple{7, Any}" href="#WaterLily.reduce_sdf_map-NTuple{7, Any}"><code>WaterLily.reduce_sdf_map</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_sdf_map(sdf_a,map_a,d_a,sdf_b,map_b,d_b,op,x,t)</code></pre><p>Reduces two different <code>sdf</code> and <code>map</code> functions, and <code>d</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.residual!-Tuple{Poisson}" href="#WaterLily.residual!-Tuple{Poisson}"><code>WaterLily.residual!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual!(p::Poisson)</code></pre><p>Computes the resiual <code>r = z-Ax</code> and corrects it such that <code>r = 0</code> if <code>iD==0</code> which ensures local satisfiability     and  <code>sum(r) = 0</code> which ensures global satisfiability.</p><p>The global correction is done by adjusting all points uniformly,  minimizing the local effect. Other approaches are possible.</p><p>Note: These corrections mean <code>x</code> is not strictly solving <code>Ax=z</code>, but without the corrections, no solution exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf-Tuple{AutoBody, Any, Any}" href="#WaterLily.sdf-Tuple{AutoBody, Any, Any}"><code>WaterLily.sdf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = sdf(body::AutoBody,x,t) = body.sdf(x,t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf-Tuple{Bodies, Any, Any}" href="#WaterLily.sdf-Tuple{Bodies, Any, Any}"><code>WaterLily.sdf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">d = sdf(a::Bodies,x,t)</code></pre><p>Computes distance for <code>Bodies</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sdf_map_d-NTuple{4, Any}" href="#WaterLily.sdf_map_d-NTuple{4, Any}"><code>WaterLily.sdf_map_d</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sdf_map_d(ab::Bodies,x,t)</code></pre><p>Returns the <code>sdf</code> and <code>map</code> functions, and the distance <code>d</code> (<code>d=sdf(x,t)</code>) for the <code>Bodies</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/AutoBody.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_step!-Tuple{Simulation, Any}" href="#WaterLily.sim_step!-Tuple{Simulation, Any}"><code>WaterLily.sim_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_step!(sim::Simulation,t_end=sim(time)+Œît;max_steps=typemax(Int),remeasure=true,verbose=false)</code></pre><p>Integrate the simulation <code>sim</code> up to dimensionless time <code>t_end</code>. If <code>remeasure=true</code>, the body is remeasured at every time step. Can be set to <code>false</code> for static geometries to speed up simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.sim_time-Tuple{Simulation}" href="#WaterLily.sim_time-Tuple{Simulation}"><code>WaterLily.sim_time</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_time(sim::Simulation)</code></pre><p>Return the current dimensionless time of the simulation <code>tU/L</code> where <code>t=sum(Œît)</code>, and <code>U</code>,<code>L</code> are the simulation velocity and length scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/WaterLily.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.slice-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any, Any}} where N" href="#WaterLily.slice-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any}, Tuple{Tuple{Vararg{T, N}} where T, Any, Any, Any}} where N"><code>WaterLily.slice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice(dims,i,j,low=1)</code></pre><p>Return <code>CartesianIndices</code> range slicing through an array of size <code>dims</code> in dimension <code>j</code> at index <code>i</code>. <code>low</code> optionally sets the lower extent of the range in the other dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.solver!-Tuple{Poisson}" href="#WaterLily.solver!-Tuple{Poisson}"><code>WaterLily.solver!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solver!(A::Poisson;log,tol,itmx)</code></pre><p>Approximate iterative solver for the Poisson matrix equation <code>Ax=b</code>.</p><ul><li><code>A</code>: Poisson matrix with working arrays.</li><li><code>A.x</code>: Solution vector. Can start with an initial guess.</li><li><code>A.z</code>: Right-Hand-Side vector. Will be overwritten!</li><li><code>A.n[end]</code>: stores the number of iterations performed.</li><li><code>log</code>: If <code>true</code>, this function returns a vector holding the <code>L‚ÇÇ</code>-norm of the residual at each iteration.</li><li><code>tol</code>: Convergence tolerance on the <code>L‚ÇÇ</code>-norm residual.</li><li><code>itmx</code>: Maximum number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Poisson.jl#L148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.time-Tuple{Flow}" href="#WaterLily.time-Tuple{Flow}"><code>WaterLily.time</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time(a::Flow)</code></pre><p>Current flow time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Flow.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.total_force-Tuple{Any}" href="#WaterLily.total_force-Tuple{Any}"><code>WaterLily.total_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>total_force(sim::Simulation)</p><p>Compute the total force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.viscous_force-Tuple{Any}" href="#WaterLily.viscous_force-Tuple{Any}"><code>WaterLily.viscous_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>viscous_force(sim::Simulation)</p><p>Compute the viscous force on an immersed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N" href="#WaterLily.Œ¥-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>WaterLily.Œ¥</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Œ¥(i,N::Int)
Œ¥(i,I::CartesianIndex{N}) where {N}</code></pre><p>Return a CartesianIndex of dimension <code>N</code> which is one at index <code>i</code> and zero elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.Œª‚ÇÇ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.Œª‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Œª‚ÇÇ(I::CartesianIndex{3},u)</code></pre><p>Œª‚ÇÇ is a deformation tensor metric to identify vortex cores. See <a href="https://en.wikipedia.org/wiki/Lambda2_method">https://en.wikipedia.org/wiki/Lambda2_method</a> and Jeong, J., &amp; Hussain, F., doi:<a href="https://doi.org/10.1017/S0022112095000462">10.1017/S0022112095000462</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.œâ-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ(I::CartesianIndex{3},u)</code></pre><p>Compute 3-vector <span>$ùõö=ùõÅ√óùêÆ$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}" href="#WaterLily.œâ_mag-Tuple{CartesianIndex{3}, Any}"><code>WaterLily.œâ_mag</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ_mag(I::CartesianIndex{3},u)</code></pre><p>Compute <span>$‚à•ùõö‚à•$</span> at the center of cell <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}" href="#WaterLily.œâ_Œ∏-Tuple{CartesianIndex{3}, Any, Any, Any}"><code>WaterLily.œâ_Œ∏</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâ_Œ∏(I::CartesianIndex{3},z,center,u)</code></pre><p>Compute <span>$ùõö‚ãÖùõâ$</span> at the center of cell <code>I</code> where <span>$ùõâ$</span> is the azimuth direction around vector <code>z</code> passing through <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.‚àÇ-NTuple{4, Any}" href="#WaterLily.‚àÇ-NTuple{4, Any}"><code>WaterLily.‚àÇ</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇ(i,j,I,u)</code></pre><p>Compute <span>$‚àÇu·µ¢/‚àÇx‚±º$</span> at center of cell <code>I</code>. Cross terms are computed less accurately than inline terms because of the staggered grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.‚àá¬≤u-Tuple{CartesianIndex{2}, Any}" href="#WaterLily.‚àá¬≤u-Tuple{CartesianIndex{2}, Any}"><code>WaterLily.‚àá¬≤u</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àá¬≤u(I::CartesianIndex,u)</code></pre><p>Rate-of-strain tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/Metrics.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@inside-Tuple{Any}" href="#WaterLily.@inside-Tuple{Any}"><code>WaterLily.@inside</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@inside &lt;expr&gt;</code></pre><p>Simple macro to automate efficient loops over cells excluding ghosts. For example,</p><pre><code class="nohighlight hljs">@inside p[I] = sum(loc(0,I))</code></pre><p>becomes</p><pre><code class="nohighlight hljs">@loop p[I] = sum(loc(0,I)) over I ‚àà inside(p)</code></pre><p>See <a href="#WaterLily.@loop-Tuple"><code>@loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L47-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterLily.@loop-Tuple" href="#WaterLily.@loop-Tuple"><code>WaterLily.@loop</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@loop &lt;expr&gt; over &lt;I ‚àà R&gt;</code></pre><p>Macro to automate fast loops using @simd when running in serial, or KernelAbstractions when running multi-threaded CPU or GPU.</p><p>For example</p><pre><code class="nohighlight hljs">@loop a[I,i] += sum(loc(i,I)) over I ‚àà R</code></pre><p>becomes</p><pre><code class="nohighlight hljs">@simd for I ‚àà R
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end</code></pre><p>on serial execution, or</p><pre><code class="nohighlight hljs">@kernel function kern(a,i,@Const(I0))
    I ‚àà @index(Global,Cartesian)+I0
    @fastmath @inbounds a[I,i] += sum(loc(i,I))
end
kern(get_backend(a),64)(a,i,R[1]-oneunit(R[1]),ndrange=size(R))</code></pre><p>when multi-threading on CPU or using CuArrays. Note that <code>get_backend</code> is used on the <em>first</em> variable in <code>expr</code> (<code>a</code> in this example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterLily-jl/WaterLily.jl/blob/0653781317c0c0e481a3d58c8f185409b0bc5173/src/util.jl#L69-L95">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 31 July 2024 23:41">Wednesday 31 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
